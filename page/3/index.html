<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xjshi.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="land">
<meta property="og:url" content="https://xjshi.github.io/page/3/index.html">
<meta property="og:site_name" content="land">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ebebya">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xjshi.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>land</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">land</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ebebya</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2016/02/28/2015-2016/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/02/28/2015-2016/" class="post-title-link" itemprop="url"></2015><2016></a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-02-28 11:19:09" itemprop="dateCreated datePublished" datetime="2016-02-28T11:19:09+00:00">2016-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很久没更新博客了，原因是发现 OneNote 记笔记更方便，所以技术性的东西就不写博客了。这篇就总结下2015年，说下2016年的计划（仅仅是计划，谁知道我会不会抽筋呢）。 </p>
<p>对于提高待遇这事一直是说不出口的，所以就有了想提薪的时候，就提离职，一提离职就加薪，两次了，不知道公司到底压榨了我多少啊。公司并不是特别喜欢，但是老大给了充分的信任，这样我有时间做喜欢的事，所以加钱了就不走了。</p>
<p>另外还参与了一个用 HTML5 实现的 App，尽管有很多问题，体验不如原生，不过还是要搞点别的，世事变幻莫测。</p>
<p>技术长进多少不敢说，列一下15年的看过的书好了，不评论的书表示不错，有评论的书看评论，当然，一切都是个人观点：</p>
<p>技术方面的：</p>
<ol>
<li>《Effective Objective-C 2.0》；</li>
<li>《Objective-C高级编程》；</li>
<li>《iOS应用逆向工程》</li>
<li>《iOS编程》<br> 这本书个人看过的感觉，配不上网上那么高的评价，除了24章，其他的感觉都很基本。</li>
<li>《iOS编程实战》<br> 个人认为这本书要比《iOS编程》好，侧重点也不同。《iOS编程》好像是在知道一个初学者，《iOS编程实战》就有点最佳实践的味道。</li>
<li>《Head First》设计模式</li>
<li>《HTTP权威指南》<br> 书很好，我还没有看完。</li>
<li>《数据库系统概念》<br> 如果在大学时候我看到过这本书，我肯定把教材扔了。</li>
<li>《Go语言编程》</li>
</ol>
<p>其他：</p>
<ol>
<li>《沉默的大多数》王小波</li>
<li>《我所理解的生活》韩寒</li>
<li>《行者无疆》余秋雨</li>
<li>《借我一生》余秋雨</li>
</ol>
<p>2016年的计划，暂时只计划到了七月：</p>
<ol>
<li>做一个个人项目；</li>
<li>再看一遍Head First设计模式；</li>
<li>看完HTTP权威指南；</li>
<li>继续看书；</li>
<li>跳槽；</li>
</ol>
<p>就这样！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/10/21/load-vs-initialize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/10/21/load-vs-initialize/" class="post-title-link" itemprop="url">load vs. initialize</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-21 13:13:04" itemprop="dateCreated datePublished" datetime="2015-10-21T13:13:04+00:00">2015-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章来对比一下NSObject类的两个方法，<code>+load</code>与<code>+initialize</code>。</p>
<h2 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load;"></a><code>+ (void)load;</code></h2><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>不管一个类、类别是被动态加载或者静态链接，都会被发送load消息，但是只有新加入的类或者类别实现了这个方法，它才可以响应。</p>
<p>The order of initialization is as follows:</p>
<ol>
<li>All initializers in any framework you link to.</li>
<li>All <code>+load</code> methods in your image.</li>
<li>All C++ static initializers and C/C++ <code>__attribute__(constructer)</code> functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>
<p>注意：</p>
<ul>
<li>一个类的<code>+load</code>方法在他所有的父类之后调用；</li>
<li>一个类别的<code>+load</code>方法，在类本身的<code>+load</code>之后调用。</li>
</ul>
<h2 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+ (void)initialize;"></a><code>+ (void)initialize;</code></h2><p>运行时在每个类或者该类的子类被首次使用时，调用该方法。父类比子类先收到该消息。</p>
<p>运行时以线程安全给每个类发送<code>initialize</code>消息。这造成<code>initialize</code>会阻塞其他线程。所以，在<code>initialize</code>中只做必须的少量工作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/09/30/iOS-%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/09/30/iOS-%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">iOS 中关于字符串的一些问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-09-30 14:08:09" itemprop="dateCreated datePublished" datetime="2015-09-30T14:08:09+00:00">2015-09-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文是看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542-CH1-SW1">Text Programming Guide for iOS</a>的简单总结。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/09/30/iOS-%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/09/24/iOS%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/09/24/iOS%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/" class="post-title-link" itemprop="url">iOS中关于线程的一些点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-09-24 20:13:25" itemprop="dateCreated datePublished" datetime="2015-09-24T20:13:25+00:00">2015-09-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><p>runloop是一个基础的设施，用来管理一个线程里异步到来的事件。runloop通过监控一个线程的一个或多个事件源来工作。当有事件到来的时候，系统就唤醒线程，然后把事件分发到runloop中，runloop会给事件分发到你指定的处理函数。如果没有事件需要处理，runloop就让线程休息。</p>
<p>为线程启动一个runloop，可以让线程用非常少的资源来一直存活。如果这个线程要不定时处理一些任务，那么启动runloop是非常合适的。</p>
<h1 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h1><p>使用线程有一个棘手的地方，那就是资源竞争。如果每个线程都有自己独占的资源，这无疑是最好。但这只是理想状况，所以，必须要通过一些手段来同步数据访问的问题。这些手段包括，lock、condition、atomic operation 等。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>使用很粗鲁的方式来保护一段代码在同一时刻只有一个线程可以执行。锁的类型，看下表：</p>
<table>
<thead>
<tr>
<th>Lock</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mutext</td>
<td>互斥锁可以看作是一个信号量，保证同一时刻只有一个线程可以访问。如果一个互斥锁正在使用，而另一个视图获取它，那么视图获取的线程就会在原持有者释放锁之前一直阻塞。</td>
</tr>
<tr>
<td>Recursive lock</td>
<td>递归锁是互斥锁的一个变种。互斥锁允许一个线程在释放锁前，多次请求锁。拥有锁的线程释放次数，需要跟请求锁的次数一样多，其他线程才能持有锁。</td>
</tr>
<tr>
<td>Read-write lock</td>
<td>also referred to as a shared-exclusive lock. 读写锁一般用语被保护的数据结构读多写少的情况。在同一个时间，可以有多个读者读取数据。当要写数据的时候，必须等到所有读者读取完成。当写数据的线程在等待锁的时候，新的读数据的线程必须等到鞋数据的线程执行完。</td>
</tr>
<tr>
<td>Distributed lock</td>
<td>分布式锁提供进程级别的互斥访问。不像一个真正的互斥量，一个分布式锁不会阻塞或者阻止一个进程运行。它只在锁忙的时候，通知进程，让进程自己决定怎么处理。</td>
</tr>
<tr>
<td>Spin lock</td>
<td>A spin lock polls its lock condition repeatedly until that condition becomes true. 旋转锁经常被用于多处理器系统中期望等待时间小的场景。在这样的场景中，来询问线程比阻塞线程更有效。</td>
</tr>
<tr>
<td>Double-checked lock</td>
<td>A double-checked lock is an attempt to reduce the overhead of taking a lock by testing the locking criteria prior to taking the lock. Because double-checked locks are <strong>potentially unsafe</strong>, the system does not provide explicit support for them and their use is <strong>discouraged</strong>.</td>
</tr>
</tbody>
</table>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件变量是另一个类型的信号量，允许线程在满足条件时互相唤醒（signal）。条件变量通常用于表示资源的可用性或者用来确保任务的执行次序。</p>
<p>当一个线程测试一个条件的时候，如果条件不为真，线程就会阻塞。条件变量与互斥锁之间的不同在于条件变量允许多个线程同时访问。</p>
<h2 id="在同一个线程中执行"><a href="#在同一个线程中执行" class="headerlink" title="在同一个线程中执行"></a>在同一个线程中执行</h2><p>把需要同步代码的执行都放到同一个线程中。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>原子操作，需要硬件指令支持。如赋值操作。</p>
<h2 id="内存隔离和Volatile变量"><a href="#内存隔离和Volatile变量" class="headerlink" title="内存隔离和Volatile变量"></a>内存隔离和Volatile变量</h2><h1 id="线程安全设计的几个建议"><a href="#线程安全设计的几个建议" class="headerlink" title="线程安全设计的几个建议"></a>线程安全设计的几个建议</h1><p>上面介绍的同步工具对实现线程安全很有帮助，但是它们不是万能的。使用太多的锁及其他的同步原语可能会降低应用的性能。你需要平衡线程安全与性能，下面给出几个小建议。</p>
<h2 id="避免完全同步"><a href="#避免完全同步" class="headerlink" title="避免完全同步"></a>避免完全同步</h2><p>实现并发最好的方式是减少并发任务之间的交互和降低内粗以来。如果每个任务有自己的私有数据，那就不需要用锁保护。比如，两个线程访问同一份数据，你可以将这个数据给每个线程分别拷贝一份。当然，你需要同衡拷贝的消耗与线程同步的消耗来做取舍。</p>
<h2 id="理解同步的限制"><a href="#理解同步的限制" class="headerlink" title="理解同步的限制"></a>理解同步的限制</h2><p>如果有一个互斥锁来限制访问特定的资源，但是你应用的所有的线程都需要请求这个互斥锁来访问这个资源。你是不是考虑一下系统设计的不好。</p>
<h2 id="明白可能存在的威胁"><a href="#明白可能存在的威胁" class="headerlink" title="明白可能存在的威胁"></a>明白可能存在的威胁</h2><p>看个列子。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span>* arrayLock = GetArrayLock();</span><br><span class="line"><span class="built_in">NSMutableArray</span>* myArray = GetSharedArray();</span><br><span class="line"><span class="keyword">id</span> anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br></pre></td></tr></table></figure>
<p>这样保证取 anObject 的过程的安全的，但是可能刚出临界区，数组被清空了，那么久没办法 doSomething 了。所以，来这样改造一下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span>* arrayLock = GetArrayLock();</span><br><span class="line"><span class="built_in">NSMutableArray</span>* myArray = GetSharedArray();</span><br><span class="line"><span class="keyword">id</span> anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[anObject doSomething];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure>
<p>取出来、执行没问题，但如果 doSomething 要很长时间的话，就会造成其他线程就等。所以，我来继续改造：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span>* arrayLock = GetArrayLock();</span><br><span class="line"><span class="built_in">NSMutableArray</span>* myArray = GetSharedArray();</span><br><span class="line"><span class="keyword">id</span> anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[anObject <span class="keyword">retain</span>];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br><span class="line">[anObject release];</span><br></pre></td></tr></table></figure>
<p>完美。</p>
<h2 id="小心死锁、活锁"><a href="#小心死锁、活锁" class="headerlink" title="小心死锁、活锁"></a>小心死锁、活锁</h2><p>这通常发生在一个线程需要不止一个锁的情况下。</p>
<p>举个死锁的例子：张三李四饿了，他俩都想要同时又了面包、牛奶再开吃。张三有面包，李四有牛奶。张三需要李四的牛奶，李四需要张三的面包。两人互不相让，最终谁都没吃成。</p>
<p>活锁这里百度百科里变的解释更像是<code>饿死</code>，维基百科里的解释可能更正确一些：独木桥，张三、李四分别在两岸，张三让李四过，李四让张三过，结果两个人因为互相让，都没过。</p>
<p>苹果官方文档里关于活锁的解释，我读不懂，这里贴上原文：</p>
<blockquote>
<p>A livelock is similar to a deadlock and occurs when two threads compete for the same set of resources. In a livelock situation, a thread gives up its first lock in an attempt to acquire its second lock. Once it acquires the second lock, it goes back and tries to acquire the first lock again. It locks up because it spends all its time releasing one lock and trying to acquire the other lock rather than doing any real work.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-07-09 16:04:06" itemprop="dateCreated datePublished" datetime="2015-07-09T16:04:06+00:00">2015-07-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>正则表达式是一种文本模式，包括普通字符（如字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途　　　　　　　　　　"></a>用途　　　　　　　　　　</h2><ul>
<li>测试字符串内的模式。例如，测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。使用正则表达式来识别文档中的特定文本，完全删除文本或者用其他文本替换。</li>
<li>基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/06/30/%E4%BD%BF%E7%94%A8-Quartz-2D-%E6%93%A6%E9%99%A4%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/06/30/%E4%BD%BF%E7%94%A8-Quartz-2D-%E6%93%A6%E9%99%A4%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">使用 Quartz 2D 擦除图片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-06-30 15:59:19" itemprop="dateCreated datePublished" datetime="2015-06-30T15:59:19+00:00">2015-06-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Quartz 2D 是一个强大的二位图像绘制引擎，在开发中如果遇到需要高度自定义的控件，我们就可能需要用Core Graphics进行绘制。</p>
<p>这几天一同事开发一个聊天中的一个子模块，A 画一幅图，然后发给 B。这需要使用到 Core Graphics，我看了他的代码，图形绘制、填充等 API 使用当然没有问题，但是在需要擦出的时候，他的实现方式是粗暴的绘制跟背景相同颜色的线条。如此不优雅的实现方式，当然不能说服我。</p>
<p>那么优雅的实现方式是什么？通过肉眼枚举<code>CGContext.h</code>中的 API，我找到了这个方法<code>CG_EXTERN void CGContextClearRect(CGContextRef cg_nullable c, CGRect rect)</code>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/06/30/%E4%BD%BF%E7%94%A8-Quartz-2D-%E6%93%A6%E9%99%A4%E5%9B%BE%E7%89%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/06/14/What-s-New-in-iOS-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/06/14/What-s-New-in-iOS-9/" class="post-title-link" itemprop="url">What's New in iOS 9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-06-14 10:05:49" itemprop="dateCreated datePublished" datetime="2015-06-14T10:05:49+00:00">2015-06-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章主要总结开发者需要关注 iOS 9 中引入的新特性。</p>
<h2 id="iPad-多任务增强"><a href="#iPad-多任务增强" class="headerlink" title="iPad 多任务增强"></a>iPad 多任务增强</h2><p>iOS 9 增强了用户在 iPad 上的多任务体验（Slide Over、Split View、Picture in Picture）。Slide Over 能让用户选择一个次要的应用，并与之交互。Split View 让用户能够同时使用两个部分（仅部分型号 iPad ，如 ipad Air 2）。PiP 能够让用户在使用其他应用的时候，观看视频。</p>
<p>对于 Slide Over 和 Split View ，开发者需要注意应用的内存展映，以及做好适配（size class）。</p>
<p>开发 PiP 的话，需要用 AVKit 或 AVFoundation 相关 API，以前的多媒体播放器 API 不支持 PiP。</p>
<h2 id="3D-Touch"><a href="#3D-Touch" class="headerlink" title="3D Touch"></a>3D Touch</h2><p>3D Touch 给用了一种额外的交互方式。在支持的设备上，在主屏（home screen）上可以通过按压应用的图标来选择应用指定的动作。在应用内部，用户可以通过不同的压力级别，进行不同的行为。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>iOS 9 中的搜索能够让用户访问到应用内的信息。在应用内容能够被搜索的时候，用户可以通过 Spotlight、Handoff、Siri suggestion 来访问应用内的内容。使用相关的 API，应用开发者来决定什么内容可以被索引，什么信息可以展示的搜索结构中，以及用户点击搜索结果时，跳转到哪里。</p>
<p>隐私也是 iOS 9 的一个特性。在给用户搜索应用信息的同时，也保护隐私数据。</p>
<h2 id="App-Thinning"><a href="#App-Thinning" class="headerlink" title="App Thinning"></a>App Thinning</h2><p>App thinning 帮助开发者针对不同平台开发应用，并且以优化的方式分发安装。App thinning 包含以下元素：</p>
<ul>
<li>Slicing。</li>
<li>On-Demand Resources。许多应用的额外信息放在 iTunes App Store 的仓库中，允许应用异步下载、安装。</li>
<li>BitCode。把你提交到 App Store 的应用打包成目标设备的可执行文件。</li>
</ul>
<h2 id="ATS"><a href="#ATS" class="headerlink" title="ATS"></a>ATS</h2><p>ATS 能加强应用与后端之间连接的安全性。</p>
<p>苹果建议尽快适配 ATS，不管是新开发的应用，还是维护以前的应用。如果是新开发的应用，你应该只是用 HTTPS。如果应用中需要跟不支持 HTTPS的服务器通信，你需要在 Info.plist 文件中指明。</p>
<h2 id="Extension-Points"><a href="#Extension-Points" class="headerlink" title="Extension Points"></a>Extension Points</h2><blockquote>
<p>extension point定义了使用策略，并且提供相关模块的 API。</p>
</blockquote>
<p>iOS 9 引入了几个新的 extension point，包括：</p>
<ul>
<li><p>Network extension points：</p>
<ul>
<li>使用 Packet Tunnel Provider 扩展点来实现客户端的自定义 VPN 通道协议。</li>
<li>使用 App Proxy Provider 扩展点来实现客户端的自定义透明网络代理协议。</li>
<li>使用 Filter Data Provider 和 Filter Control Provider 扩展点来实现动态的、设备上网络内容过滤。<br>每一个网络扩展带你都需要苹果的特殊权限。</li>
</ul>
</li>
<li><p>Safari extension points：</p>
<ul>
<li>使用 Shared Link 扩展点能让用户在 Safari 的分享链接中看到你的内容。</li>
<li>Content Blocking 扩展点给 Safari 一个黑名单，这个黑名单描述了你想要阻止你的用户浏览的内容。</li>
</ul>
</li>
<li><p>Index Maintenance 扩展点支持在不重新打开应用的情况下，重建应用数据的索引。</p>
</li>
<li>Audio Unit 扩展点允许你的应用提供乐器、音效、声音发生器等。</li>
</ul>
<h2 id="Contacts-and-Contants-UI"><a href="#Contacts-and-Contants-UI" class="headerlink" title="Contacts and Contants UI"></a>Contacts and Contants UI</h2><p>iOS 9 引入的 Contacts 和 Contants UI 来替换 AddressBook 与 AddressBook UI，与后者比，前者更加面向对象。</p>
<h2 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h2><p>这部分不太好描述，直接引入苹果官方文档的原文。</p>
<p>The keychain provides more item protection options and a new type of encryption keys owned by the secure enclave. Specifically:</p>
<ul>
<li>New constraints for access control lists that allow creating constraints with Touch ID only or passcode only.</li>
<li>A new Touch ID constraint that invalidates keychain items when a fingerprint is added or removed.</li>
<li>Support for app-provided entropy for keychain item encryption using the Application Password option of the access control list.</li>
<li>Support for an authentication context that lets you invoke the authentication separately from SecItem calls.</li>
<li>Support for keys generated and used inside the secure enclave using the kSecAttrTokenIDSecureEnclave attribute. Note that access to these keys can be controlled by all constraints supported by access control lists</li>
</ul>
<h2 id="Support-for-Right-to-Left-Languages"><a href="#Support-for-Right-to-Left-Languages" class="headerlink" title="Support for Right-to-Left Languages"></a>Support for Right-to-Left Languages</h2><p>iOS 9 全面支持从右向左书写的语音，这会让 UI 开发更简单。比如：</p>
<ul>
<li>标准的 UIKit 控件在从右至左的情况下自动反转。</li>
<li><code>UIView</code> 定义语义上的内容属性，能够让你指定在从右至左的上下文中视图应该如何展示。</li>
<li><code>UIImage</code>添加了<code>imageFlippedForRightToLeftLayoutDirection</code>方法，让反转图片更简单。</li>
</ul>
<p>除了上边描述的，还有部分框架的改动，具体的 API 变化，可以看这里：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/releasenotes/General/iOS90APIDiffs/index.html#//apple_ref/doc/uid/TP40016222">iOS 9.0 API Diffs</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/05/03/%E8%87%AA%E5%AE%9A%E4%B9%89-TabBar-%E4%B9%8B%E7%90%86%E8%A7%A3-hittest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/05/03/%E8%87%AA%E5%AE%9A%E4%B9%89-TabBar-%E4%B9%8B%E7%90%86%E8%A7%A3-hittest/" class="post-title-link" itemprop="url">自定义 TabBar 之理解 hittest</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-05-03 10:23:16" itemprop="dateCreated datePublished" datetime="2015-05-03T10:23:16+00:00">2015-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>需求的TabBar是这样的：5个 tabItem， 中间的那个 item 部分超出系统默认TabBar的上边界。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/05/03/%E8%87%AA%E5%AE%9A%E4%B9%89-TabBar-%E4%B9%8B%E7%90%86%E8%A7%A3-hittest/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/04/04/Event-Delivery-The-Responder-Chain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/04/04/Event-Delivery-The-Responder-Chain/" class="post-title-link" itemprop="url">Event Delivery: The Responder Chain</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-04-04 20:08:43" itemprop="dateCreated datePublished" datetime="2015-04-04T20:08:43+00:00">2015-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>当我们设计语言的时候，我们很可能想动态的响应事件。例如，触摸一个拥有许多不同对象的屏幕，你要决定给哪个对象一个响应事件，怎么样对象接收到事件。</p>
<p>当一个用户产生事件发生时（如 点击），UIKit 产生一个对象，这个包含要被处理的对象的信息。接着把事件对象放到 active app’s（一个application对象，负责初始化用户事件路由、从全局管理一个运行的application）事件队列中。对于触摸事件，这个对象是一组触摸，打包放在 UIEvent 对象。对 motion 事件而言，事件对象根据你使用框架的不同和你感兴趣的 motion 事件类型而有所差异。</p>
<p>一个事件对象沿一个明确的路径传递，直到有个对象可以处理它。首先，单例 UIApplication 对象从队列的顶部取一个事件，并进行分发处理。一般，UIApplication 对象把事件发给应用的 key window 对象，key window 对象传递给一个 initial 对象来处理。这个 initial 对象取决于事件的类型。</p>
<ul>
<li>Touch events。对于触摸事件，window 对象首先尝试将事件发送给事件发生的 view（hit-test view）。找到 hit-test view 的过程被称为 hit-testing（我们将在后边谈到）。</li>
<li>Motioin and remote control enents。这类事件，window 对象发送 shaking-motion 或者 remote control event 给第一响应者处理。</li>
</ul>
<p>事件路径（event paths）的终极目标是找到一个对象来处理响应一个事件。因此，UIKit 首先把这个事件发送给最适合处理这个时间的对象。对于触摸事件，这个对象是 hit-test view；对于其他事件，这个对象是第一响应者。下面的部分介绍关于确定 hit-test view 和第一响应者的更多细节。</p>
<p>Hit-Testing Returns the View Where a Touch Occurred（hit-test 返回触摸发生的 view）。有的地方翻译感觉很别扭，为了避免误导（真的有人看吗？），原文贴上。</p>
<p>iOS use hit-testing fo find the view that is under a touch. Hit-testing involves checking whether a touch is within the bounds fo any relevant（更多强调直接相关） view objects. If it is, it recursively checks all of that view’s subviews. The lowest view in the view hierarchy that contains the touch point becomes the hit-test view. After iOS determines the hit-test view, it passes the touch event to that view for handling.</p>
<p>举例说明，假设用户在 View E 中触摸，iOS通过用下面的次序检查 subviews 来查找 hit-test view：</p>
<p>触摸在 view A 的 bounds 内，所以检查 subview B 和 C；<br>触摸不在 View B 的 bounds 内，但在 View C 的 bounds 内，所以检查 subview D 和 E；<br>触摸不在 View D 的 bounds 内，但在 view E 的 bounds 内。<br>View E is the lowest view in the view hierarchy that contains the touch, so it becomes the hit-test view.</p>
<img src="/2015/04/04/Event-Delivery-The-Responder-Chain/hit-test.png" class="">
<p><code>hitTest:withEvent:</code> 方法返回一个 CGPoint 和 UIEvent 的 hit-test view。 <code>hitTest:withEvent:</code> 方法开始执行通过 view 本身调用 <code>pointInside:withEvent:</code> 方法。如果传入<code>pointInside:withEvent:</code>的点在 view 的 bounds 内，<code>pointInside:withEvent:</code>返回 YES。接着，在这个 view 的每个 subview 上调用 <code>hitTest:withEvent:</code>。</p>
<p>传入<code>hitTest:withEvent:</code>的点不在 view 的 bounds 中得情况不细说了。</p>
<p>注意：一个触摸事件在它的整个生命周期中和它的 hit-test view 相关联，即使稍后触摸移出了这个 view。</p>
<p>hit-test view 被给予了第一次来处理触摸事件的机会。如果 hit-test view 不能处理这个事件，事件将沿这个 view 的响应者链条往下走，直到找到一个可以处理事件的对象。</p>
<p> The Responder Chain Is Made Up of Responder Objects（响应者链条由响应者组成-。-）</p>
<p>许多类型的事件以来响应链条传递事件。响应者链条是一系列连起来的响应者对象。以第一响应者开始，结束于 application 对象。如果第一响应者不能处理一个事件，它就转发给响应者链条中的下一个响应者。</p>
<p>A responder object is an object that can respond to and handle events. The  UIResponder  class is the base class for all responder objects, and it defines the programmatic interface not only for event handling but also for common responder behavior. Instances of the UIApplication, UIViewController, and UIView classes are responders, which means that all views and most key controller objects are responders. Note that Core Animation layers are not responders.</p>
<p>第一响应者被指定首先接受事件。通常，第一响应者是一个 view 对象。一个对象可以变成第一响应者通过做下面两件事：</p>
<p>重写 canBecomeFirstResponder 方法，返回YES;<br>接受一个 becomeFirstResponder 消息。如果必要，一个对象可以给自己发送这条消息。<br>依赖响应者链条的对象不止事件对象。响应者链条可以用在下面的地方：</p>
<ol>
<li>Touch events.</li>
<li>Motion events.</li>
<li>Remote control events.</li>
<li>Action messages.</li>
<li>Editing-menu messages.</li>
<li>Text editing.</li>
</ol>
<p>UIKit自动设置用户点击的text field 或 text view成为第一响应者；Apps必须显式设置所有其他的第一响应者，用becomeFirstResponder方法。</p>
<p>更多详细内容可查阅苹果开发者文档：<br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xjshi.github.io/2015/03/30/NSURLSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ebebya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="land">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/03/30/NSURLSession/" class="post-title-link" itemprop="url">NSURLSession</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-30 21:28:17" itemprop="dateCreated datePublished" datetime="2015-03-30T21:28:17+00:00">2015-03-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>NSURLSession 这个类和与其有关联的其他类，提供一个通过 HTTP 下载的 API。这个 API 提供丰富的代理方法可以让你的app在挂起或者没有运行的时候，在后台下载。</p>
<p>用 NSURLSession API，你的应用可以创建一系列的 session，每一个 session 协调一组关联的数据转存任务。举个例子：你在协议一个网络浏览器，你的应用可以创建为每个<br>tab 或每个 window 创建一个 session。在每个 session 中，你的应用添加一系列的任务，每一个任务代表一个指定 URL 的请求。</p>
<p>三种类型 session：<strong>default session</strong> behave similary to other Foundation methods for downloading URLs,使用基于磁盘的 cache，并且在用户的钥匙串中存储 credentials，<strong>ephemeral session</strong> 不在磁盘上做缓存，所有的缓存、credential等都保持在 RAM 里，和 session 绑定；<strong>background session</strong> 它的行为跟 default session 相似，但它用一个单独的进程处理数据传输。把结果存在一个文件中，并且在app挂起、退出、崩溃的时候仍然继续转存数据。</p>
<p>在这些 session 中，你可以安排三种类型的任务：</p>
<p>　　<strong>data task</strong> 用 NSData 对象收发数据，Data task are intended for short, often interative request from you app to a server。可以一次返回一块数据，或者通过 completion handler 一次返回所有数据。Because data task do not store the data to file, they are not supported in background sessions。</p>
<p>　　<strong>download task</strong> retrieve data in the form of file, and support background downloads while the app is not running。</p>
<p>　　<strong>upload task</strong> send data(usuall in the form of a file),and support background uploads while the app is not running。</p>
<p>像大多数的网络 API 一样，NSURLSession 是高度异步的，它根据你调用的方法，用一种或两种方法返回数据：</p>
<ul>
<li>一个 handler block，当转存完成或者出错的时候，给你的app返回数据。</li>
<li>通过调用你自定义的代理，当数据被收到的时候。</li>
<li>通过调用方法在自定义的代理上，当下载数据完成。</li>
</ul>
<p>NSURLSession 的 API 除了传送信息给代理，也提供状态和过程属性。支持取消、重新开始、继续、挂起任务，并且有继续  挂起、取消或者失败的下载的能力。</p>
<h2 id="URL-Sessioin-Class-Hierarchy"><a href="#URL-Sessioin-Class-Hierarchy" class="headerlink" title="URL Sessioin Class Hierarchy"></a>URL Sessioin Class Hierarchy</h2><p>NSURLSession API包括下面这些类：</p>
<ul>
<li>NSURLSession:一个session对象</li>
<li>NSURLSessionConfiguration: 初始化 session 时用得配置对象。</li>
<li><p>NSURLSessionTask：session 中任务的基类。</p>
<ul>
<li>NSURLSessionDataTask：任务用于获取一个 URL 的内容（作为 NSData）。<ul>
<li>NSURLSessionUploadTask：上传文件，接着取回一个 URL 的内容（作为 NSData）。</li>
</ul>
</li>
<li>NSURLSessionDownloadTask：获取一个 URL 的内容作为一个临时文件放在磁盘上。</li>
</ul>
</li>
</ul>
<p>除此之外，NSURLSession 的 API 提供了四个协议，你的app可以实现它们的代理方法以对 session 和 task 的行为进行更颗粒化（精细）的控制。</p>
<ul>
<li>NSURLSessionDelegate：处理 session-level 事件。</li>
<li>NSURLSessionTaskDelegate：处理 task-level 事件，对所有任务类型可用。</li>
<li>NSURLSessionDataDeleg：处理 task-level 事件，只对 data task 和 upload task 有用。</li>
<li>NSURLSessionDownloadDelegate：处理 task-level 事件，只对 download task 有用。</li>
</ul>
<p>最后，NSURLSession 的 API 用许多类，这些类也经常和其他 API 一起用（比如 NSURLConnection 和 NSURLDownload ）。</p>
<ul>
<li>NSURL：</li>
<li>NSURLRequest：封装和URL request相关的元数据（metadata），包括URL，request方法，等等。</li>
<li>NSURLResponse：封装和服务器对请求的响应有关的元数据，比如内容的MIME类型和长度。<ul>
<li>NSHTTPURLResponse：为HTTP request添加额外的，比如响应头。</li>
</ul>
</li>
<li>NSCachedURLResponse:封装一个NSURLRespo对象（与服务器响应体的真实数据一起），目的是cache。</li>
</ul>
<h2 id="Background-Transfer-Considerations"><a href="#Background-Transfer-Considerations" class="headerlink" title="Background Transfer Considerations"></a>Background Transfer Considerations</h2><p>使用 background session 的时候，因为实际的传输由一个单独的进程来执行，也因为重启应用的代价相对比较大，因此，一些特性不可用，造成下面的限制：</p>
<ul>
<li>The session must provide a delegate for event delivery.(For uploads and downloads, the delegate behave the same as for in-process transfer.)</li>
<li>只支持HTTP/HTTPS协议，不支持自定义协议。</li>
<li>只支持upload task、download task，不支持data task。</li>
<li>Redirects are always follows.</li>
<li>If the background transfer is initiated while the app is in the background, the configuration object’s discretionary property is treated as being true.</li>
</ul>
<p>在 iOS 中，当后台传输完成或者需要资格(require credentials)，如果应用没有在运行，iOS 自动重启应用并调用<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法在<code>UIApplicationDelegate</code>对象上。This call provides the identifier for the session that caused your app to be lunched. 你的app应该存储这个 completionHandler，用这个 identifier 创建 background configuration object，然后用这个配置对象创建session。The new session is automatically reassociated with on going background activity. Later, when the session finishes the last background download task, it sends the session delegate a URLSessionDidFinishEventsForBackgroundURLSession: message. Your session delegate should then call the stored completion handler.</p>
<p>In both iOS and OS X, when the user relaunches your app, your app should immediately create background configuration objects with the same identifiers as any session that had outstanding tasks when your app was last running, then create a session for each of those configuration objects. These new sessions are similary automatically reassociated with ongoing backgorund activity.</p>
<p>当你的app被挂起的时候，如果任何任务完成，这个任务的代理的<code>URLSession:downloadTask:didFinishDownloadingToURL:</code>  方法被调用。</p>
<p>Similarly, if any task requires credentials, the NSURLSession object calls the delegate’s <code>URLSession:task:didReceiveChallenge:completionHandler:</code> method or <code>URLSession:didReceiveChallenge:completionHandler:</code> method as appropriate. </p>
<h2 id="创建和配置"><a href="#创建和配置" class="headerlink" title="创建和配置"></a>创建和配置</h2><p>NSURLSession API提供的配置选项:</p>
<ul>
<li>Private storage support for caches,cookies,credentials,and protocols in a way that is specific to a single session.</li>
<li>Authentication,tied to a specific request(task) or group of requests(session)。</li>
<li>File uploads and downloads by URL,which encourage separation of the data (the file’s contents)from the metadata(the URL and settings)</li>
<li>Configuration of the maximum number of connections per host</li>
<li>Per-source timeouts that are triggered if an entire resource cann’t be downloaded in a certain mount of time</li>
<li>Minimum and maximum TLS version support</li>
<li>Custom proxy dictionaries</li>
<li>Control over cookie policies</li>
<li>Control over pipelining bahavior</li>
</ul>
<hr>
<p>博客搬家时的题外话：使用 NSURLSession 完全可以实现断点下载、后台下载，而且非常好用，需要仔细读读 URL Loading System 和 App 的生命周期相关文档，然后留意一个方法<code>getTasksWithCompletionHandler:</code>。别看某“大神”的“关于下载管理的探讨”讨论了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ebebya</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
