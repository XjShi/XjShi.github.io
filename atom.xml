<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>land</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xjshi.github.io/"/>
  <updated>2023-12-13T12:25:29.689Z</updated>
  <id>https://xjshi.github.io/</id>
  
  <author>
    <name>ebebya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>俞敏洪：我曾走在崩溃的边缘</title>
    <link href="https://xjshi.github.io/2023/12/13/%E4%BF%9E%E6%95%8F%E6%B4%AA%EF%BC%9A%E6%88%91%E6%9B%BE%E8%B5%B0%E5%9C%A8%E5%B4%A9%E6%BA%83%E7%9A%84%E8%BE%B9%E7%BC%98/"/>
    <id>https://xjshi.github.io/2023/12/13/俞敏洪：我曾走在崩溃的边缘/</id>
    <published>2023-12-13T19:37:26.000Z</published>
    <updated>2023-12-13T12:25:29.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>北京大学、英语老师、出国潮、在当时顶级的英语教学水平。</p><h2 id="大厨效应"><a href="#大厨效应" class="headerlink" title="大厨效应"></a>大厨效应</h2><p>大厨效应。会经营的老板不一定会做菜，会做菜的大厨不一定懂经营。如果你要开一个饭店自己不会做菜，还想要大厨不“造反”的话，那就得配2-3个大厨，让大厨之间能互相制衡。</p><span id="more"></span><h2 id="遇到问题的解决思路"><a href="#遇到问题的解决思路" class="headerlink" title="遇到问题的解决思路"></a>遇到问题的解决思路</h2><ul><li>没有办学许可证，就找东方大学合作。</li><li>与教育局的沟通，条件的变通。</li><li>单位出具证明过程中，曾经学生的意外帮助</li></ul><h2 id="人际关系"><a href="#人际关系" class="headerlink" title="人际关系"></a>人际关系</h2><p>能力超强的同学、室友。使用家族成员的利弊。</p><h2 id="俞敏洪给同学朋友一起创业的建议。"><a href="#俞敏洪给同学朋友一起创业的建议。" class="headerlink" title="俞敏洪给同学朋友一起创业的建议。"></a>俞敏洪给同学朋友一起创业的建议。</h2><p>第一，利益结构一定要清晰分明，明确每个人到底占多少股份。第二，利益分配结构一定要是动态的，因为未来发展过程中谁的贡献大现在是不确定的。比如股权分配，三个同学每人拥有30%的股权，但三年以后还是不是每人拥有30%的股权，就不一定了。未来，可以根据每个人岗位的重要性和贡献的多少改变期权，对于由个人的贡献产生的股权差距，大家也不会有什么意见。第三，要有清晰的上下级结构。也就是说，最终谁听谁的这样的决策机制是一定要有的。大家平时可以是同学，但是遇到问题的时候，一定要有人能够说了算。比如：五个同学决策时，就以三票及以上为通过；三个同学决策时，由“老大”说了算，这个“老大”是大家公认的，比如公司的CEO或者董事长。总之，不能出现没有人说了算的局面。新东方后来出现的问题，都是因为到最后没人能说了算。</p><h2 id="变革"><a href="#变革" class="headerlink" title="变革"></a>变革</h2><p>推动变革最重要的要素，既不是理想，也不是情感，甚至不是未来，而是利益的分配机制。也就是说，当所有人或绝大部分人都意识到变革能给自己带来巨大的利益和良好的未来预期的时候，这个变革就特别容易推进了。</p><h2 id="卢跃刚对新东方稳定起到的作用。"><a href="#卢跃刚对新东方稳定起到的作用。" class="headerlink" title="卢跃刚对新东方稳定起到的作用。"></a>卢跃刚对新东方稳定起到的作用。</h2><p>但是卢跃刚在这中间起到了一个作用，因为要写书——虽然当时我们都不太主张——他就要去跟每一个人交流，所以就变成了我们新东方每一个人的朋友。当时的情况就成了，徐小平、王强跟我没法说对抗的话，就跟卢跃刚说，而我对王强、徐小平的观点和意见也可以跟卢跃刚说。所以，卢跃刚本来是一个第三方，而现在要担起两个角色：一是充分了解我们每个人心里在想什么；二是变成了我们这些人的缓冲，这也意味着我们可以找第三方去倾诉，不至于互相之间直接硬碰硬地打架。这样的话，我们之间就有了一个缓冲地带。比方说，卢跃刚能够明确地告诉徐小平：“小平，你太情绪化了，情绪化的东西是完全不算数的，所以只要你情绪化就是错的。”然后，他可以对我说：“俞敏洪，这件事情你应该理性地对待，以这样的方式来对待。”</p><p>由于他是第三方，在新东方也没有个人利益，大家会认为他说的话是公正的，没有偏向任何一方，所以也都愿意跟他去聊。另外，我们坐在一起开会的时候，有卢跃刚坐在边上就会好很多，因为大家知道他在写书，而且到最后我们发现他这部书已经非写不可了——因为他对这些超级感兴趣，他不在乎企业本身做得好不好，但在乎企业内部的斗争和矛盾，以及斗争、矛盾的解决方式。所以大家很默契地有了一个共同认知：只要卢跃刚在场，开会时自己一定要理性，因为自己的任何爆发或者不讲道理，到最后一定会被卢跃刚写到书里去。这样一来，也缓解了我们硬碰硬地对着干的情况。就这样，卢跃刚在这两年多组织结构改造的过程中，成了新东方人重要的倾诉对象和心理安慰，很好地缓冲了新东方的利益纠葛。所以，我对卢跃刚特别感激，因为我想如果没有他的话，新东方很有可能就散架了。后来，我常说，卢跃刚是老天派来的，使新东方当时的问题得到了和平的解决。尽管他在商业逻辑、上市公司规范和规则方面也不是专家，但是毕竟做了很多关于企业、商业的报道，也看过很多企业的发展，所以对我们来说，他还起到了另外一方的咨询作用。</p><h2 id="逆境中的心态"><a href="#逆境中的心态" class="headerlink" title="逆境中的心态"></a>逆境中的心态</h2><p>无论人在什么岗位上，在任何困境中，都要让自己保持进步。</p><blockquote><p>不要用别人的错误，惩罚自己。</p></blockquote><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="点滴成长"><a href="#点滴成长" class="headerlink" title="点滴成长"></a>点滴成长</h3><p>一个人的成长可以用一条河来比喻，起源处都是非常狭窄的，但是在向前流动的过程中，河面一般都会变得越来越开阔。原因就是各种支流的汇入，水量也会越来越大。所以像长江、黄河这样的河流，最后到达大海的时候都变成了奔流的大河。但是我们也会发现，有些人像流着流着水量越来越小的河，就像沙漠中间的断头河一样，到最后就是水渗透到沙漠中，没有了踪影，人生也变成一片荒芜。那人与人之间的主要区别在什么地方呢？我们还以河流做比喻，那些支流的汇入、水量的增加，就是你不断吸纳外来的、使你成长的因素的结果。如果你更愿意去学习，更愿意去自我驱动，更愿意去交有意义的朋友，更愿意读书，那所有这些东西就像点点滴滴的水流汇聚到你的生命之流中，让你到最后能够变得越来越开阔。</p><p>同时，我们也可以把河流向前的流动解释为一种自我驱动。我们都知道，河流向前流是从高处流往低处产生的自我驱动，而人生向前却是从低处往高处走产生的自我驱动，所以，人生的自我驱动比河流的自我驱动要更加艰难——因为我们要往上走。但是不管怎样，你的这种自我驱动能成为你生命发展的动力。所以我认为，自我成长的驱动是人成长最主要的动力之一。</p><p>我是农民的儿子，经过三年高考进入北大，在北大努力学习，最后留在北大当老师，从一名普通老师变成优秀老师，后来又从北大出来做新东方，从零做起，把新东方做成了在美上市公司。这一过程背后的逻辑其实就是一种自我驱动，就是一个想让自己变得更有价值、更能干、更有作为的过程。这种自我驱动就是人成长的第一要素。</p><p>第二个要素就是要敢于改变。一条河流在流动的过程中会经过不同的环境，从雪山到高原、峡谷，最后到平原，到大海，如果不流动就可能变成一个湖了。而湖的位置是相对固定的，水量也不会变。所以，河水流动的过程就是进入新环境的过程。而我说要改变自己，就是一定要进入某种新的环境，也就是要创造让自己能够得到锻炼和成长的新环境。</p><h3 id="知识结构对新东方发展的影响"><a href="#知识结构对新东方发展的影响" class="headerlink" title="知识结构对新东方发展的影响"></a>知识结构对新东方发展的影响</h3><h3 id="做人做事的核心要素：诚信、坦诚和信任"><a href="#做人做事的核心要素：诚信、坦诚和信任" class="headerlink" title="做人做事的核心要素：诚信、坦诚和信任"></a>做人做事的核心要素：诚信、坦诚和信任</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;北京大学、英语老师、出国潮、在当时顶级的英语教学水平。&lt;/p&gt;
&lt;h2 id=&quot;大厨效应&quot;&gt;&lt;a href=&quot;#大厨效应&quot; class=&quot;headerlink&quot; title=&quot;大厨效应&quot;&gt;&lt;/a&gt;大厨效应&lt;/h2&gt;&lt;p&gt;大厨效应。会经营的老板不一定会做菜，会做菜的大厨不一定懂经营。如果你要开一个饭店自己不会做菜，还想要大厨不“造反”的话，那就得配2-3个大厨，让大厨之间能互相制衡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://xjshi.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>简单看了眼tinyfool经常提到的日历控件源代码</title>
    <link href="https://xjshi.github.io/2016/11/27/%E7%AE%80%E5%8D%95%E7%9C%8B%E4%BA%86%E7%9C%BCtinyfool%E7%BB%8F%E5%B8%B8%E6%8F%90%E5%88%B0%E7%9A%84%E6%97%A5%E5%8E%86%E6%8E%A7%E4%BB%B6%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <id>https://xjshi.github.io/2016/11/27/简单看了眼tinyfool经常提到的日历控件源代码/</id>
    <published>2016-11-27T17:11:26.000Z</published>
    <updated>2023-12-13T12:25:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>先贴上源码地址：<a href="https://code.google.com/archive/p/iphonecal/source/default/source">Here</a></p><p>代码是是08年写的，这点还是非常服的，这个时候我还在上高中。08年到现在OC在一些特性上改进很多，其中使用的<code>CFGregorianDate</code>相关api在iOS 8.0之后也不建议使用了，所以这里我只说我确认不是好的实践的部分。</p><span id="more"></span><p><strong>先来看下头文件:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CalendarView.h</span></span><br><span class="line"><span class="comment">//  ZhangBen</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by tinyfool on 08-10-26.</span></span><br><span class="line"><span class="comment">//  Copyright 2008 __MyCompanyName__. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CalendarViewDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TdCalendarView</span> : <span class="title">UIView</span> </span>&#123;</span><br><span class="line"><span class="built_in">CFGregorianDate</span> currentMonthDate;</span><br><span class="line"><span class="built_in">CFGregorianDate</span> currentSelectDate;</span><br><span class="line"><span class="built_in">CFAbsoluteTime</span>currentTime;</span><br><span class="line"><span class="built_in">UIImageView</span>* viewImageView;</span><br><span class="line"><span class="keyword">id</span>&lt;CalendarViewDelegate&gt; calendarViewDelegate;</span><br><span class="line"><span class="keyword">int</span> *monthFlagArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CFGregorianDate</span> currentMonthDate;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CFGregorianDate</span> currentSelectDate;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CFAbsoluteTime</span>  currentTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">UIImageView</span>* viewImageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>&lt;CalendarViewDelegate&gt; calendarViewDelegate;</span><br><span class="line">-(<span class="keyword">int</span>)getDayCountOfaMonth:(<span class="built_in">CFGregorianDate</span>)date;</span><br><span class="line">-(<span class="keyword">int</span>)getMonthWeekday:(<span class="built_in">CFGregorianDate</span>)date;</span><br><span class="line">-(<span class="keyword">int</span>)getDayFlag:(<span class="keyword">int</span>)day;</span><br><span class="line">-(<span class="keyword">void</span>)setDayFlag:(<span class="keyword">int</span>)day flag:(<span class="keyword">int</span>)flag;</span><br><span class="line">-(<span class="keyword">void</span>)clearAllDayFlag;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CalendarViewDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>) selectDateChanged:(<span class="built_in">CFGregorianDate</span>) selectDate;</span><br><span class="line">- (<span class="keyword">void</span>) monthChanged:(<span class="built_in">CFGregorianDate</span>) currentMonth viewLeftTop:(<span class="built_in">CGPoint</span>)viewLeftTop height:(<span class="keyword">float</span>)height;</span><br><span class="line">- (<span class="keyword">void</span>) beforeMonthChange:(TdCalendarView*) calendarView willto:(<span class="built_in">CFGregorianDate</span>) currentMonth;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>代码格式我就不说了，空格写的很随意，大小写对于我这种强迫症来说也很受不了。最重要的是我认为这雨苹果framework中命名方式大不同。<br>interface中的命名大多数都还不错，但是<code>-(void)setDayFlag:(int)day flag:(int)flag;</code>这个是什么鬼，我认为<code>- (void)setFlag:(int)flag forDay:(int)day;</code>更好。</p><p><strong>下面来看下源文件：</strong></p><p>源文件中定义了全局的几个变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> headHeight=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> itemHeight=<span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> prevNextButtonSize=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> prevNextButtonSpaceWidth=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> prevNextButtonSpaceHeight=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> titleFontSize=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>weekFontSize=<span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>这几个变量主要是来控制试图的大小、字体的大小，只有在这个文件内部使用，但没有用<code>static</code>修饰。</p><p><strong>学C语言的时候，大概都做过这么一个练习：<em>获取某年某月的天数</em>。来看看tinyfool的实现：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)getDayCountOfaMonth:(<span class="built_in">CFGregorianDate</span>)date&#123;</span><br><span class="line"><span class="keyword">switch</span> (date.month) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span>((date.year % <span class="number">4</span>==<span class="number">0</span> &amp;&amp; date.year % <span class="number">100</span>!=<span class="number">0</span>) || date.year % <span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">29</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">28</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现没有问题，但我认为查表是更好的方式。  </p><font color=red>Update: 微博上有讨论这个问题，表示这样写不会有什么问题，编译器会对这种情况做优化。</font><p><strong>实现中有很多类似的实践（个人认为这不是好的实践）：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)movePrevMonth&#123;</span><br><span class="line"><span class="keyword">if</span>(currentMonthDate.month&gt;<span class="number">1</span>)</span><br><span class="line">currentMonthDate.month-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">currentMonthDate.month=<span class="number">12</span>;</span><br><span class="line">currentMonthDate.year-=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span> movePrevNext:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再来看下这个类的析构函数：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">    free(monthFlagArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Excuse me. 这里虽然不太可能出现崩溃的情况，但不是应该先释放子类持有的资源？  </p><font color=red>Update: tinyfool说在早期SDK的bug比较多，要实验各种方法避免内存泄漏，有些写法比较诡异，但是在某个版本下，反而效果是好的。</font><p><strong>最后，总结一些tinyfool的变量命名风格：<code>title_Month</code>、<code>weekfont</code>、<code>tabHeight</code>、<code>s_width</code>。</strong></p><hr><p>Update: 之前写的时候描述不太恰当，因此修改了一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先贴上源码地址：&lt;a href=&quot;https://code.google.com/archive/p/iphonecal/source/default/source&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码是是08年写的，这点还是非常服的，这个时候我还在上高中。08年到现在OC在一些特性上改进很多，其中使用的&lt;code&gt;CFGregorianDate&lt;/code&gt;相关api在iOS 8.0之后也不建议使用了，所以这里我只说我确认不是好的实践的部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="胡说八道" scheme="https://xjshi.github.io/tags/%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Enumerations</title>
    <link href="https://xjshi.github.io/2016/11/19/Swift-Enumerations/"/>
    <id>https://xjshi.github.io/2016/11/19/Swift-Enumerations/</id>
    <published>2016-11-19T21:30:32.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>Enumerations in Swift are flexible, and do not have to provide a value for each case of the enumeration. If a value(known as “raw” value) if provied for each enumeration case, the value can be a string, a character, or a value of any integer for floating-point type.  </p><span id="more"></span><h2 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> north</span><br><span class="line"><span class="keyword">case</span> south</span><br><span class="line"><span class="keyword">case</span> east</span><br><span class="line"><span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个case可以写在一行，用逗号分隔  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> mercuy, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br><span class="line"></span><br><span class="line">directionToHead <span class="operator">=</span> .east</span><br></pre></td></tr></table></figure><h2 id="关联值-Associated-Values"><a href="#关联值-Associated-Values" class="headerlink" title="关联值(Associated Values)"></a>关联值(Associated Values)</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br></pre></td></tr></table></figure><p>提取关联的值:  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">var</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果关联的值都要提取为常量或者都要提取为变量，可以这样写:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSytem, manufacturer, product, check):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Raw-Values"><a href="#Raw-Values" class="headerlink" title="Raw Values"></a>Raw Values</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//raw value可以是字符串、字符、任何整型、浮点型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Implicitly-Assigned-Raw-Values"><a href="#Implicitly-Assigned-Raw-Values" class="headerlink" title="Implicitly Assigned Raw Values"></a>Implicitly Assigned Raw Values</h3><p>当你使用枚举存储整型或者字符串类型的raw value时，没有必要给每一个case赋值。整型从0开始，字符串的raw value是case的名字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RefinementPlanet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, vanus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RefinementCompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder is 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection is &quot;west&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Initializing-from-a-Raw-Value"><a href="#Initializing-from-a-Raw-Value" class="headerlink" title="Initializing from a Raw Value"></a>Initializing from a Raw Value</h3><p>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called rawValue) and returns either an enumeration case or nil.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">RefinementPlanet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">//possiblePlanet的类型是 RefinementPlanet?</span></span><br></pre></td></tr></table></figure><h2 id="Recursive-Enumerations"><a href="#Recursive-Enumerations" class="headerlink" title="Recursive Enumerations"></a>Recursive Enumerations</h2><p>递归枚举是一个枚举的一个或者多个case使用另一个枚举的实例作为关联值。通过的case前写<code>indirect</code>来表示这个case是递归的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Enumerations in Swift are flexible, and do not have to provide a value for each case of the enumeration. If a value(known as “raw” value) if provied for each enumeration case, the value can be a string, a character, or a value of any integer for floating-point type.  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Initialization-2</title>
    <link href="https://xjshi.github.io/2016/11/11/Swift-Initialization-2/"/>
    <id>https://xjshi.github.io/2016/11/11/Swift-Initialization-2/</id>
    <published>2016-11-11T23:24:18.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Failable-Initializers"><a href="#Failable-Initializers" class="headerlink" title="Failable Initializers"></a>Failable Initializers</h2><p>有的时候，可能是参数问题、需要的外部资源没有到位等原因，初始化可能失败。为了应对这种情况，我们可以定义一个或多个可失败的构造方法。 <code>init？</code></p><p>A failable initiazlier creates an optional value of the type it initializes.</p><p>通过返回nil来表示初始化失败，看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">species</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.species <span class="operator">=</span> species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someCreature <span class="operator">=</span> <span class="type">Animal</span>(species: <span class="string">&quot;Giraffe&quot;</span>)</span><br><span class="line"><span class="comment">//someCreature的类型是Animal?</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe <span class="operator">=</span> someCreature &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Failable-Initializers-for-Enumerations"><a href="#Failable-Initializers-for-Enumerations" class="headerlink" title="Failable Initializers for Enumerations"></a>Failable Initializers for Enumerations</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin, celsius, fahrenheit</span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">symbol</span>: <span class="type">Character</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;K&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .kelvin</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .celsius</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .fahrenheit</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Failable-Initializers-for-Enumerations-with-Raw-Values"><a href="#Failable-Initializers-for-Enumerations-with-Raw-Values" class="headerlink" title="Failable Initializers for Enumerations with Raw Values"></a>Failable Initializers for Enumerations with Raw Values</h3><p>Enumerations with raw values automatically receive a failable initializer, <code>init?(rawValue):)</code>, that takes a parameter called <code>rawValue</code> of the appropriate raw-value type and selects a matching enumeration case if one if found, ro triggers an initialization failure if no matching value exists.</p><p>把上面的例子改写一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin <span class="operator">=</span> <span class="string">&quot;K&quot;</span>, celsius <span class="operator">=</span> <span class="string">&quot;C&quot;</span>, fahrenheit <span class="operator">=</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Propagation-of-Initialization-Failure"><a href="#Propagation-of-Initialization-Failure" class="headerlink" title="Propagation of Initialization Failure"></a>Propagation of Initialization Failure</h3><p>一个类、结构体、枚举的可失败的构造方法可以delegate across同一个类型中另一个可失败的构造方法。子类的一个可失败的构造方法可以delegate up父类的可失败的构造方法。</p><p>一个可失败的构造方法也可以delegate to不可失败的构造方法。</p><p>看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> quantity <span class="operator">&lt;</span> <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Overriding-a-Failable-Initializer"><a href="#Overriding-a-Failable-Initializer" class="headerlink" title="Overriding a Failable Initializer"></a>Overriding a Failable Initializer</h3><p>父类的可失败的构造函数可以被重写为可失败的或者不可失败的。看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// this initializer creates a document with a nil name value</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// this initializer creates a document with a nonempty name value</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-init-Failable-Initializer"><a href="#The-init-Failable-Initializer" class="headerlink" title="The init! Failable Initializer"></a>The init! Failable Initializer</h3><p><code>init!</code> implicitly unwrapped optional instance</p><h2 id="Required-Initiazliers"><a href="#Required-Initiazliers" class="headerlink" title="Required Initiazliers"></a>Required Initiazliers</h2><p>在构造方法的定义前边加上<code>required</code>修饰符来表示这个类的每一个子类都必须实现这个构造方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当重写一个required指定构造器时，不用在前边加<code>override</code>修饰。</p><p>注意：<strong>如果你可以使用一个继承的构造方法来满足的话，那么你可以不提供一个显式的required构造方法。</strong><br>比如说我们定义一个子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，没有问题。我们也可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写也没有问题，因为<code>init()</code>方法被自动继承了。我们接着看：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样因为我们自定义了一个指定构造方法，<code>SomeSubClass</code>不会自动继承父类的指定构造方法（<code>init()</code>），所以编译器会提示我们一个错误。</p><h2 id="Setting-a-Default-Property"><a href="#Setting-a-Default-Property" class="headerlink" title="Setting a Default Property"></a>Setting a Default Property</h2><p>主要用途是为存储属性进行一些处理，可以使用全局函数或者闭包。看起来大概是这个样子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// create a default value for someProperty inside this closure</span></span><br><span class="line">        <span class="comment">// someValue must be of the same type as SomeType</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Failable-Initializers&quot;&gt;&lt;a href=&quot;#Failable-Initializers&quot; class=&quot;headerlink&quot; title=&quot;Failable Initializers&quot;&gt;&lt;/a&gt;Failable Initializers&lt;/
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Siwft: Initialization-1</title>
    <link href="https://xjshi.github.io/2016/11/11/Siwft-Initialization-1/"/>
    <id>https://xjshi.github.io/2016/11/11/Siwft-Initialization-1/</id>
    <published>2016-11-11T18:12:05.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>初始化的过程包括为每一个存储属性设置一个初始值和其他步骤。通过定义构造函数来实现初始化的过程，跟oc的初始化函数不同，Swift的构造函数不返回一个值。它们的主要角色是确保一个类型的实例在初次使用前被正确的初始化。</p><span id="more"></span><p>类的实例也可以有析构函数，析构函数在类的实例在释放前完成一些清理工作。</p><h2 id="Setting-Initial-Values-for-Stored-Properties"><a href="#Setting-Initial-Values-for-Stored-Properties" class="headerlink" title="Setting Initial Values for Stored Properties"></a>Setting Initial Values for Stored Properties</h2><p>类和结构体必须为它们所有的存储属性设置一个初始值，在类或结构体的实例创建完成前。存储属性不能是不确定的状态。</p><p>可以通过构造函数或默认值的方式给存储属性一个初始值，而且通过这两种方式，属性的值都是被直接设置，不会调用属性观察者。</p><h3 id="Initializers（构造函数）"><a href="#Initializers（构造函数）" class="headerlink" title="Initializers（构造函数）"></a>Initializers（构造函数）</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Customizing-Initialization（自定义初始化函数）"><a href="#Customizing-Initialization（自定义初始化函数）" class="headerlink" title="Customizing Initialization（自定义初始化函数）"></a>Customizing Initialization（自定义初始化函数）</h2><p>你可以自定义初始化过程，通过使用输入参数，可选的属性类型，或者在初始化期间给常量属性赋值。具体描述在下面的部分中描述。</p><h3 id="1-Initialization-Parameters"><a href="#1-Initialization-Parameters" class="headerlink" title="1. Initialization Parameters"></a>1. Initialization Parameters</h3><p>你可以为构造函数提供参数，看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">celsius</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bodyTemperature <span class="operator">=</span> <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br></pre></td></tr></table></figure><h4 id="Parameter-Names-and-Argument-Labels"><a href="#Parameter-Names-and-Argument-Labels" class="headerlink" title="Parameter Names and Argument Labels"></a>Parameter Names and Argument Labels</h4><p>Swift provides an autoamtic argument label for every parameter in an initializer if you don’t provide one.看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">red</span>: <span class="type">Double</span>, <span class="params">green</span>: <span class="type">Double</span>, <span class="params">blue</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.red <span class="operator">=</span> red</span><br><span class="line">        <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">        <span class="keyword">self</span>.blue <span class="operator">=</span> blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">white</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        red <span class="operator">=</span> white</span><br><span class="line">        green <span class="operator">=</span> white</span><br><span class="line">        blue <span class="operator">=</span> white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样初始化一个<code>Color</code>的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> megenta <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray <span class="operator">=</span> <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h4 id="Initializer-Parameters-Without-Argument-Labels"><a href="#Initializer-Parameters-Without-Argument-Labels" class="headerlink" title="Initializer Parameters Without Argument Labels"></a>Initializer Parameters Without Argument Labels</h4><p>参考上边<code>Celsius</code>类中的第三个构造方法，及<code>bodyTemperature</code>的初始化。</p><h3 id="2-Optional-Property-Types"><a href="#2-Optional-Property-Types" class="headerlink" title="2. Optional Property Types"></a>2. Optional Property Types</h3><p>如果你自定义的类型有一个存储属性在逻辑上允许“没有值”——或许是因为在初始化期间不能设置设置它的值，也可能是在后边的某个时间点允许它“没有值”，那么可以把这个属性声明为<em>optional type</em>。optional type的属性被自动初始化为<code>nil</code>。原文如下：</p><p>“If your custom type has a stored property that is logically allowed to have “no value”—perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point—declare the property with an optional type. Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization.”</p><p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 3).” iBooks. </p><p>看下下边这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;YES, i do like chesse.&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-Assigning-Constant-Properties-During-Initialization"><a href="#3-Assigning-Constant-Properties-During-Initialization" class="headerlink" title="3. Assigning Constant Properties During Initialization"></a>3. Assigning Constant Properties During Initialization</h3><p>你可以在初始化期间给一个常量属性赋一个值，只要在初始化完成时有一个明确的值就可以。</p><p>注意：对于类的实例，常量属性只能由引入该属性的类在初始化期间修改，不能被子类修改。</p><p>可以在上边那个类稍作修改，观察text属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;YES, i do like chesse.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Default-Initializers（默认构造函数）"><a href="#Default-Initializers（默认构造函数）" class="headerlink" title="Default Initializers（默认构造函数）"></a>Default Initializers（默认构造函数）</h2><p>在类或结构体为每个属性提供默认值并且没有其他构造函数时，Swift提供默认构造函数。默认构造函数简单的创建一个实例并把其所有属性设置成默认值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingList</span>()</span><br></pre></td></tr></table></figure><p>上面的例子中，如果我们不给<code>quantity</code>设置默认值，编译器将提示<code>ShoppingList</code>类没有构造函数。</p><h3 id="Memberwise-Initializers-for-Structure-Types"><a href="#Memberwise-Initializers-for-Structure-Types" class="headerlink" title="Memberwise Initializers for Structure Types"></a>Memberwise Initializers for Structure Types</h3><p>结构体类型如果没有自定义的构造函数，那么会有一个<em>memberwise initializer</em>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><h2 id="Initializer-Delegation-for-Value-Types"><a href="#Initializer-Delegation-for-Value-Types" class="headerlink" title="Initializer Delegation for Value Types"></a>Initializer Delegation for Value Types</h2><p>Initializers can call other initializers to perform part of an instance’s initialization. This process, known as <em>initializer delegation</em>, avoids duplicating code across multiple initializers.</p><p>对于值类型，可以使用<code>self.init</code>来引用该类型的其他构造函数。<code>self.init</code>只能在构造函数内使用。看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">size</span>: <span class="type">Size</span>, <span class="params">point</span>: <span class="type">Point</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">        <span class="keyword">self</span>.point <span class="operator">=</span> point</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">size</span>: <span class="type">Size</span>, <span class="params">center</span>: <span class="type">Point</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> size.width <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> size.height <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(size: size, point: <span class="type">Point</span>(x: originX, y: originY))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中第一个构造函数其实就相当于默认构造函数，第二个相当于memberwise initializer，第三个是完全自定义的。这个例子还有一种写法，可以不写<code>init()</code>和<code>init(size:point:)</code>，需要用到extension。</p><p>如果为值类型自定义了一个构造函数，那就不能再访问默认构造函数了。如果你想要你定义的值类型既可以使用默认构造函数，也可以使用自定义的构造函数，那需要把自定义的构造函数写在extension中。</p><h2 id="Class-Inheritance-and-Initialization"><a href="#Class-Inheritance-and-Initialization" class="headerlink" title="Class Inheritance and Initialization"></a>Class Inheritance and Initialization</h2><p>一个类所有的存储属性包括从父类继承的属性，都以徐在初始化几千有一个初始值。</p><p>Swift为类类型定义了两种类型的构造函数来确保存储属性有一个初始值，分别是<em>designated initializer</em>和<em>convenience initializer</em>。在下面的讨论中，我们分别把这两种称为指定构造函数、便利构造函数。</p><p>每个类都必须至少有一个指定构造函数。在一些条件下，这个需求通过从父类继承指定构造函数来满足。</p><p>便利构造函数可以调用该类中的指定构造函数。</p><h3 id="Syntax-for-Designated-and-Convenience-Initializers"><a href="#Syntax-for-Designated-and-Convenience-Initializers" class="headerlink" title="Syntax for Designated and Convenience Initializers"></a>Syntax for Designated and Convenience Initializers</h3><p>指定构造函数的语法：</p><p><img src="./pic/designated_initializer_syntax.png" alt="Designated Initalizer"></p><p>便利构造函数的语法：</p><p><img src="./pic/convenience_initializer_syntax.png" alt="Convenience Initializer"></p><h3 id="Initializer-Delegation-for-Class-Types"><a href="#Initializer-Delegation-for-Class-Types" class="headerlink" title="Initializer Delegation for Class Types"></a>Initializer Delegation for Class Types</h3><p>为了简化指定构造函数与遍历构造函数之间的关系，Swift在构造函数间的delegation call上使用下边三条规则：</p><ol><li>A designated initializer must call a designated initializer from its immediate superclass.</li><li>A convenience initializer must call another initializer from the same class.</li><li>A convenience initiazlier must ultimately call a designated initializer.</li></ol><p>可以简单的这样记：</p><ul><li>Designated initializers must always delegate up.</li><li>Convenience initiazlizers must always delegate across.</li></ul><p>这里有一个示意图来说明上面描述的规则：</p><p><img src="./pic/initializer_delegation_rules.png" alt="initializer_delegation_rules"></p><h3 id="Two-Phase-Initialization"><a href="#Two-Phase-Initialization" class="headerlink" title="Two-Phase Initialization"></a>Two-Phase Initialization</h3><p>在Swift中类的初始化分为两个阶段。在第一个阶段，类的每一个存储属性由引入其的类赋一个初始值，一旦每一个存储属性的初始状态确定了，第二个几段就开始了。第二个阶段开始以后，每个类在类可以使用前都有机会给每一个存储属性进行进一步自定义。</p><p>跟oc中的初始化有些许不同，主要体现在第一个阶段，在第一个阶段中，oc给每一个属性赋0值（如0、nil）。</p><p>Swift的编译器执行四步安全性检查(safaty-check)来确保两个阶段的初始化没有问题：</p><ol><li><strong>A designated initializer must ensure that all of the properties introduced by its class are initizlied before it delegates up to a superclass initializer.</strong></li><li><strong>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property.</strong> If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</li><li><strong>A convenience initializer must delegate to another initializer before assigning a value to any property.</strong> If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</li><li><strong>An initializer cannot call any instance methods, read the value of any instance properties, or refer to <code>self</code> as a value until after the first phase of initialization is complete.</strong></li></ol><h3 id="Initializer-Inheritance-and-Overriding"><a href="#Initializer-Inheritance-and-Overriding" class="headerlink" title="Initializer Inheritance and Overriding"></a>Initializer Inheritance and Overriding</h3><p>跟oc不同，Swift中的子类默认不继承父类的构造方法。当你为子类定义了一个构造方法，这个构造方法match一个父类的指定构造方法，你实际上是对那个指定构造方法进行了重写。因此，自己在子类构造方法前边用<code>override</code>标记。这个原则对于默认构造方法也适用。看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> : <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Automatic-Initializer-Inheritance"><a href="#Automatic-Initializer-Inheritance" class="headerlink" title="Automatic Initializer Inheritance"></a>Automatic Initializer Inheritance</h3><p>正如上边提到的，默认情况下，子类不继承弗雷德构造方法。但是，在满足一些条件的前提下，父类的构造方法可以被自动继承。</p><p>假设你已经为子类新引入的属性提供了默认值，那么有下面两条规则适用：</p><ol><li>如果子类没有定义任何指定构造方法，那么子类会自动继承父类所有的指定构造方法。</li><li>如果子类提供了父类所有指定构造方法（不论是规则1提到的，还是通过自定义实现），那么子类自动继承父类所有的便利构造方法。<strong>需要注意，子类可以把父类指定构造方法实现为便利构造方法，这样也可以满足这个条件</strong></li></ol><p>这些规则即使在子类添加了便利构造方法时，依然适用。</p><h3 id="Designated-and-Convenience-Initializer-in-Action"><a href="#Designated-and-Convenience-Initializer-in-Action" class="headerlink" title="Designated and Convenience Initializer in Action"></a>Designated and Convenience Initializer in Action</h3><p>在这一部分，我们通过一个例子来解释上边的两条规则。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">//指定构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;super versioin&quot;</span>)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//便利构造方法</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Unnamed]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sub version&quot;</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这两个类的构造方法可以用下标的图来清楚的展示：</p><p><img src="./pic/RecipeIngredient.png" alt="RecipeIngredient"></p><p>我们直接看一下<code>RecipeIngredient</code>类，首先有一个自定义的指定构造方法<code>init(name:quantity:)</code>，然后有一个自定义的便利构造方法<code>init(name:)</code>，这个方法实际上是重写了<code>Food</code>类的唯一的一个指定构造方法，所以满足了上面的第二条原则，因此自动继承<code>Food</code>类所有的便利构造方法，即<code>init()</code>方法。这里需要注意的是，<code>RecipeIngredient</code>继承来的<code>init()</code>方法中，调用的<code>init(name:)</code>不是<code>Food</code>版本的，而是<code>RecipeIngredient</code>版本的。</p><p>现在再来定义一个类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(quantity)</span> * <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> purchased <span class="operator">?</span> <span class="string">&quot;✔️&quot;</span> : <span class="string">&quot;❌&quot;</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ShoppingListItem</code>本身没有定义任何的构造方法，因此它从父类继承所有的构造方法。此时，示意图如下：</p><p><img src="./pic/ShoppingListItem.png" alt="ShoppingListItem"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初始化的过程包括为每一个存储属性设置一个初始值和其他步骤。通过定义构造函数来实现初始化的过程，跟oc的初始化函数不同，Swift的构造函数不返回一个值。它们的主要角色是确保一个类型的实例在初次使用前被正确的初始化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Inheritance</title>
    <link href="https://xjshi.github.io/2016/11/11/Swift-Inheritance/"/>
    <id>https://xjshi.github.io/2016/11/11/Swift-Inheritance/</id>
    <published>2016-11-11T17:17:38.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>为了在属性值改变的时候获得通知，类可以为继承的属性添加属性观察者。属性观察者可以添加到任何属性上，不管这个属性原来是存储属性还是计算属性。</p><p>Swift中的类没有一个统一的基类。</p><p>为了讲明白继承，我们先来定义一个基类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;traveling at <span class="subst">\(currentSpeed)</span> miles per hour&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span>()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义一个子类继承自<code>Vehicle</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写以<code>override</code>开头，任何不带<code>override</code>关键字的重写，都会在编译时判断为一个错误。</p><h3 id="访问超类的方法、属性、下标"><a href="#访问超类的方法、属性、下标" class="headerlink" title="访问超类的方法、属性、下标"></a>访问超类的方法、属性、下标</h3><ul><li>父类有一个被重写的someMethod()方法：<code>super.someMethod()</code></li><li>父类有一个被重写的someProperty属性：<code>super.someProperty</code></li><li>父类有一个对于someIndex的下标被重写：<code>super[someIndex]</code></li></ul><h3 id="Override-Methods"><a href="#Override-Methods" class="headerlink" title="Override Methods"></a>Override Methods</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Choo Choo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写属性的getter-setter"><a href="#重写属性的getter-setter" class="headerlink" title="重写属性的getter/setter"></a>重写属性的getter/setter</h3><p>不论原来的属性时存储型还是计算型，你都可以提供一个自定义的getter来重写这个继承的属性。一个属性时存储型，还是计算型，子类并不知道，子类只知道被继承的属性有一个确定的名字和类型。你要规定你重写的属性的名字和类型，来让编译器检查你的重写跟父类中的属性有相同的名字和属性。如果觉得这段不好理解，可以看下原文：</p><p>“The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type. You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.”</p><p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 3).” iBooks. </p><p>看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gear <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description <span class="operator">+</span> <span class="string">&quot; in gear <span class="subst">\(gear)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写属性观察者"><a href="#重写属性观察者" class="headerlink" title="重写属性观察者"></a>重写属性观察者</h3><p>你可以使用属性重写给继承的属性添加属性观察者。</p><p>因为常量存储型属性和只读的计算型属性不能被设置新值，所有不能给这样的属性通过继承添加属性观察者。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear <span class="operator">=</span> <span class="type">Int</span>(currentSpeed <span class="operator">/</span> <span class="number">10.0</span>) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Perventing-Overrides"><a href="#Perventing-Overrides" class="headerlink" title="Perventing Overrides"></a>Perventing Overrides</h2><p>可以把一个方法、属性、下标标记为<code>final</code>来防止其被重写，也可以把真个类用<code>final</code>来标记，任何企图重写final标记的，都会报一个运行时错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了在属性值改变的时候获得通知，类可以为继承的属性添加属性观察者。属性观察者可以添加到任何属性上，不管这个属性原来是存储属性还是计算属性。&lt;/p&gt;
&lt;p&gt;Swift中的类没有一个统一的基类。&lt;/p&gt;
&lt;p&gt;为了讲明白继承，我们先来定义一个基类：&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Subcripts</title>
    <link href="https://xjshi.github.io/2016/11/11/Swift-Subcripts/"/>
    <id>https://xjshi.github.io/2016/11/11/Swift-Subcripts/</id>
    <published>2016-11-11T16:24:19.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>类、结构体、枚举都可以定义下标（subscript），下标是访问集合、列表、序列的元素的快捷方式。</p><p>在Swift中可以为类型定义下标，而且不限于一维。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>下标定义的方法：跟实例方法的语法类似，<code>subscript</code>关键字，一个或多个输入参数，一个返回值。</p><p>下标可以是可读可写的，也可以是只可读的，由getter和setter决定，跟computed property类似。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// return an appropriate subscript value here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="comment">// perform a suitable setting action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newValue的类型跟下标操作的返回值的类型相同，与计算属性一样，你可以不指定newValue这个参数，那么会默认提供一个newValue。</p><p>跟只读的计算属性一样，只读的下标也可以这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="comment">// return a appropriate subscript value here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Subscript-Options"><a href="#Subscript-Options" class="headerlink" title="Subscript Options"></a>Subscript Options</h2><p>下标可以带任意数量的输入参数，这些参数可以是任何类型。下标也可以返回任何类型。<strong>下标可以使用可变参数（variadic parameters），蚕食不能使用in-out参数，或者提供默认参数值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类、结构体、枚举都可以定义下标（subscript），下标是访问集合、列表、序列的元素的快捷方式。&lt;/p&gt;
&lt;p&gt;在Swift中可以为类型定义下标，而且不限于一维。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Classes and Structures</title>
    <link href="https://xjshi.github.io/2016/11/10/Swift-Classes-and-Structures/"/>
    <id>https://xjshi.github.io/2016/11/10/Swift-Classes-and-Structures/</id>
    <published>2016-11-10T22:09:01.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对比类与结构体"><a href="#对比类与结构体" class="headerlink" title="对比类与结构体"></a>对比类与结构体</h2><p>类与结构体有许多的相同点，它们都可以：  </p><ul><li>定义属性来存储值；</li><li>定义方法来提供功能；</li><li>定义下标操作；</li><li>定义初始化函数；</li><li>扩展它的默认的实现；</li><li>遵从协议；</li></ul><p>类有一些额外的能力，但是结构体没有：</p><ul><li>继承；</li><li>类型转换可以让你在运行时check、interpret类的实例的类型；</li><li>析构函数（Deinitializer）；</li><li>引用计数允许不止一个指向类实例的引用；</li></ul><p><strong>结构体的传递总是复制，不使用引用计数</strong></p><span id="more"></span><h3 id="结构体的成员逐一初始化函数"><a href="#结构体的成员逐一初始化函数" class="headerlink" title="结构体的成员逐一初始化函数"></a>结构体的成员逐一初始化函数</h3><p>所有的结构体都有一个自动生成的<em>memberwise initializer</em>，看下这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样直接生成一个Resolution:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br></pre></td></tr></table></figure><p>也可以使用<em>memberwise initializer</em>来初始化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure><h2 id="结构体和枚举是值类型-Value-Type"><a href="#结构体和枚举是值类型-Value-Type" class="headerlink" title="结构体和枚举是值类型(Value Type)"></a>结构体和枚举是值类型(Value Type)</h2><p><strong>所谓值类型，是指当它被赋值给一个变量或常量，或者传递给一个函数时，它的值被复制。</strong>在Swift中，所有的基本类型，包括整型、浮点型、布尔型、字符串、数组、字典都是值类型，他们都是使用结构体实现的。Swift中所有的结构体、枚举也都是值类型。</p><h2 id="类是引用类型-Reference-Type"><a href="#类是引用类型-Reference-Type" class="headerlink" title="类是引用类型(Reference Type)"></a>类是引用类型(Reference Type)</h2><p>当给常量或者变量赋值，或者传递给函数的时候，引用类型不会被复制。</p><h3 id="Identity-Operators"><a href="#Identity-Operators" class="headerlink" title="Identity Operators"></a>Identity Operators</h3><p>用于确定两个常量或变量是不是指向（refer to）一个相同的类对象。  </p><ul><li>Identical to: <code>===</code></li><li>Not identical to: <code>!===</code></li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>If you have experience with C, C++, or Objective-C, you may know that these languages use pointers to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but is not a direct pointer to an address in memory, and does not require you to write an asterisk (*) to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对比类与结构体&quot;&gt;&lt;a href=&quot;#对比类与结构体&quot; class=&quot;headerlink&quot; title=&quot;对比类与结构体&quot;&gt;&lt;/a&gt;对比类与结构体&lt;/h2&gt;&lt;p&gt;类与结构体有许多的相同点，它们都可以：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义属性来存储值；&lt;/li&gt;
&lt;li&gt;定义方法来提供功能；&lt;/li&gt;
&lt;li&gt;定义下标操作；&lt;/li&gt;
&lt;li&gt;定义初始化函数；&lt;/li&gt;
&lt;li&gt;扩展它的默认的实现；&lt;/li&gt;
&lt;li&gt;遵从协议；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类有一些额外的能力，但是结构体没有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承；&lt;/li&gt;
&lt;li&gt;类型转换可以让你在运行时check、interpret类的实例的类型；&lt;/li&gt;
&lt;li&gt;析构函数（Deinitializer）；&lt;/li&gt;
&lt;li&gt;引用计数允许不止一个指向类实例的引用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结构体的传递总是复制，不使用引用计数&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Methods</title>
    <link href="https://xjshi.github.io/2016/11/10/Swift-Methods/"/>
    <id>https://xjshi.github.io/2016/11/10/Swift-Methods/</id>
    <published>2016-11-10T15:50:09.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>这里的“方法”指的是跟特定类型有关系的函数。</p><p>方法包括实例方法(Instance Method)和类型方法(Type Method)。实例方法可以访问所有该类型所有其他的实例方法和属性。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="在实例方法中修改值类型的数据-Modifying-Value-Types-from-Within-Instance-Mothod"><a href="#在实例方法中修改值类型的数据-Modifying-Value-Types-from-Within-Instance-Mothod" class="headerlink" title="在实例方法中修改值类型的数据(Modifying Value Types from Within Instance Mothod)"></a>在实例方法中修改值类型的数据(Modifying Value Types from Within Instance Mothod)</h3><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中修改，但是，如果你需要这么做，你可以为这个方法选择<code>mutating</code>行为。这样这个方法这可以修改它的属性，并且在方法执行结束时把这个修改写回原来的结构体中。甚至，你可以把一个完全新的实例赋值给<code>self</code>属性，这个新的实例将完全替换原来的那个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy2</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x: x <span class="operator">+</span> deltaX, y: y <span class="operator">+</span> deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在枚举中，可以把self设置成一个不同的case，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>在<code>func</code>关键字前加上<code>static</code>关键字来表示类方法。对于类，也可以使用<code>class</code>关键字来允许子类重写父类的实现。</p><p>在类方法中，隐藏的<code>self</code>属性指向类型本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的“方法”指的是跟特定类型有关系的函数。&lt;/p&gt;
&lt;p&gt;方法包括实例方法(Instance Method)和类型方法(Type Method)。实例方法可以访问所有该类型所有其他的实例方法和属性。&lt;/p&gt;
&lt;h2 id=&quot;实例方法&quot;&gt;&lt;a href=&quot;#实例方法&quot; cl
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Properties</title>
    <link href="https://xjshi.github.io/2016/11/09/Swift-Properties/"/>
    <id>https://xjshi.github.io/2016/11/09/Swift-Properties/</id>
    <published>2016-11-09T23:30:55.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>属性常与类、结构体、枚举联系在一起。stored properties存储常量值、变量值，而computed properties计算一个值。类、结构体、枚举都可以有computed property，但是只有类与结构体可以有stored property。</p><h2 id="Stored-Properties"><a href="#Stored-Properties" class="headerlink" title="Stored Properties"></a>Stored Properties</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line"><span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line">rangeOfThressItems.firstValue <span class="operator">=</span> <span class="number">6</span><span class="comment">//ok</span></span><br><span class="line"><span class="keyword">let</span> rangeOfFourItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line">rangeOfFourItems.firstValue <span class="operator">=</span> <span class="number">6</span><span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>###Lazy Stored Properties<br>lazy stored property的值直到第一次使用时才会被计算。</p><blockquote><p>注意:</p></blockquote><blockquote><ul><li>lazy stored property必须声明为变量，不能是常量。因为这样的属性的值可能会在初始化完成后才获得，而常量属性必须在初始化函数执行完成前有一个值。</li><li>这样的属性，在没有被初始化的情况下同时被多个线程同时访问，不能保证这个属性只初始化一次。</li></ul></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileName <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some date&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(manager.importer.fileName)<span class="comment">//importer在这里才被创建</span></span><br></pre></td></tr></table></figure><h3 id="Stored-Properties-and-Instance-Variables"><a href="#Stored-Properties-and-Instance-Variables" class="headerlink" title="Stored Properties and Instance Variables"></a>Stored Properties and Instance Variables</h3><p>在oc中有两种方式来为类存储值或引用，一是实例变量的方式，二是属性。<br>Swift统一了这些概念，只有声明属性的方式。Swift中的property没有对应的实例变量。</p><h2 id="Computed-Properties"><a href="#Computed-Properties" class="headerlink" title="Computed Properties"></a>Computed Properties</h2><p>类、结构体、枚举都可以定义computed property，computed property不存储值，相反，他们提供一个getter和一个可选的setter来获取和设置其他属性和值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2.0</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2.0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        set(newCenter) &#123;</span></span><br><span class="line"><span class="comment">            origin.x = newCenter.x - (size.width / 2)</span></span><br><span class="line"><span class="comment">            origin.y = newCenter.y - (size.height / 2)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">                  size:<span class="type">Size</span>(width: <span class="number">10.0</span>, height:<span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSuqareCenter <span class="operator">=</span> square.center</span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;quare.origin is now at <span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的例子中<code>Rect</code>的<code>center</code>属性是computed property。</p><p>如果setter没有为新值定义一个名字，默认的名字是<code>newValue</code>。</p><h3 id="Read-Only-Computed-Properties"><a href="#Read-Only-Computed-Properties" class="headerlink" title="Read-Only Computed Properties"></a>Read-Only Computed Properties</h3><p>可以通过移除<code>get</code>关键字和它对应的括号来简单声明一个read-only computed property，看个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Property-Observers"><a href="#Property-Observers" class="headerlink" title="Property Observers"></a>Property Observers</h2><p>属性观察者监测并相应属性值的变化。没一次一个属性值被设置的时候，观察者都被调用。</p><ol><li>除了lazy stored property，你可以给你定义的任何stored property添加属性观察者。</li><li>你也可以通过在子类中重写继承的属性（stored或者computed都可以），来给属性添加属性观察者。</li><li>没有必要给没有重写的computed property添加观察者，因为你可以在setter中观察和相应值的变化。</li></ol><p><code>willSet</code>在值被存储前调用，<code>didSet</code>在新值被存储后立即调用。(newValue,oldValue)</p><p>如果你在自己的<code>didSet</code>中给属性赋了一个新值，这个新值会替换掉刚刚设置的值。</p><blockquote><p>The <code>willSet</code> and <code>didSet</code> observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Abount to set totalSteps to <span class="subst">\(newTotalSteps)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps <span class="operator">&gt;</span> oldValue &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Added <span class="subst">\(totalSteps <span class="operator">-</span> oldValue)</span> steps&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">360</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你把一个有属性观察者的属性传递给一个函数的in-out参数，那么<code>willSet</code>和<code>didSet</code>总是会被调用。这是由in-out参数的内存模型决定的。</p></blockquote><h2 id="Type-Properties"><a href="#Type-Properties" class="headerlink" title="Type Properties"></a>Type Properties</h2><p>type property可以理解为C++中的静态成员变量。<br>stored type property可以是变量或者常量。computed type property只能声明称变量。</p><p>跟stored instance property不一样的是，你必须给stored type property一个默认值。因为类型本身没有初始化函数可以给stored type property赋值。</p><p>stored type property是lazy initalized，可以确保在多线程条件下只初始化一次。</p><h3 id="Type-Property-Syntax"><a href="#Type-Property-Syntax" class="headerlink" title="Type Property Syntax"></a>Type Property Syntax</h3><p>可以使用<code>static</code>关键字来定义type property。对于类类型的computed type property，可以使用<code>class</code>关键字来允许子类重写父类的实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;属性常与类、结构体、枚举联系在一起。stored properties存储常量值、变量值，而computed properties计算一个值。类、结构体、枚举都可以有computed property，但是只有类与结构体可以有stored property。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Functions</title>
    <link href="https://xjshi.github.io/2016/11/09/Swift-Functions/"/>
    <id>https://xjshi.github.io/2016/11/09/Swift-Functions/</id>
    <published>2016-11-09T20:39:29.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="默认参数值-Default-Parameter-Values"><a href="#默认参数值-Default-Parameter-Values" class="headerlink" title="默认参数值(Default Parameter Values)"></a>默认参数值(Default Parameter Values)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认参数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">10</span>)</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">10</span>, parameterWithDefault: <span class="number">23</span>)</span><br></pre></td></tr></table></figure><h3 id="可变长参数-Variadic-Parameters"><a href="#可变长参数-Variadic-Parameters" class="headerlink" title="可变长参数(Variadic Parameters)"></a>可变长参数(Variadic Parameters)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>,<span class="number">13.23</span>)</span><br></pre></td></tr></table></figure><p><em>一个函数最多有一个可边长参数</em></p><h3 id="In-Out-Parameters"><a href="#In-Out-Parameters" class="headerlink" title="In-Out Parameters"></a>In-Out Parameters</h3><ul><li>函数参数默认是常量，如果你想要修改一个参数的值，并且让这个改变在函数调用结束后依然有效，就要把参数定义为in-out。  </li><li>语法：在参数类型前边加<code>inout</code>关键字。  </li><li>只能把变量传递给函数的inout参数，不能传递一个常量或者字面值，因为常量或者字面值不能够被修改。  </li><li>可以在变量名字前边放<code>&amp;</code>符号，表示变量可以被函数改变。  </li></ul><p><em>in-out参数不能有默认值，可变参数不能标记为inout。</em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;默认参数值-Default-Parameter-Values&quot;&gt;&lt;a href=&quot;#默认参数值-Default-Parameter-Values&quot; class=&quot;headerlink&quot; title=&quot;默认参数值(Default Parameter Values)&quot;
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: Basic Operators</title>
    <link href="https://xjshi.github.io/2016/11/09/Swift-Basic-Operators/"/>
    <id>https://xjshi.github.io/2016/11/09/Swift-Basic-Operators/</id>
    <published>2016-11-09T12:09:51.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p><em>这里只讲一下Swift中比较特殊的操作符，在其他语言中也存在操作符就不再讲了</em>  </p><h2 id="Nil-Coalescing-Operator"><a href="#Nil-Coalescing-Operator" class="headerlink" title="Nil-Coalescing Operator: ??"></a>Nil-Coalescing Operator: ??</h2><p>The nil-coalescing operator (<code>a ?? b</code>) unwraps an optional a if it contains a value, or returns default value b if a is nil.<br>这里的表达式<code>a</code>必须是optional type，表达式<code>b</code>的类型必须和存储在a中的值的类型相同。实际上这个运算符是下边这行代码的简写  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> a<span class="operator">!</span> : b</span><br></pre></td></tr></table></figure><p><strong>这个操作符跟<code>&amp;&amp;</code>类似，都短路计算（short-circuit evaluation）特性。</strong></p><h2 id="Range-Operator"><a href="#Range-Operator" class="headerlink" title="Range Operator"></a>Range Operator</h2><p>Swift包含两个范围操作符</p><h3 id="Closed-Range-Operator-a…b"><a href="#Closed-Range-Operator-a…b" class="headerlink" title="Closed Range Operator: a…b"></a>Closed Range Operator: a…b</h3><p><code>a...b</code>定义了一个从a到b的范围（包含a和b），a的值不能比b大。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> times 5 is <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Half-Open-Range-Operator"><a href="#Half-Open-Range-Operator" class="headerlink" title="Half-Open Range Operator"></a>Half-Open Range Operator</h3><p><code>a..&lt;b</code>定义一个从a到b的范围（不包括b），a的值不能比b大。  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> names.count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Person <span class="subst">\(i <span class="operator">+</span> <span class="number">1</span>)</span> is called <span class="subst">\(names[i])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这里只讲一下Swift中比较特殊的操作符，在其他语言中也存在操作符就不再讲了&lt;/em&gt;  &lt;/p&gt;
&lt;h2 id=&quot;Nil-Coalescing-Operator&quot;&gt;&lt;a href=&quot;#Nil-Coalescing-Operator&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift: The Basics</title>
    <link href="https://xjshi.github.io/2016/11/09/Swift-The-Basics/"/>
    <id>https://xjshi.github.io/2016/11/09/Swift-The-Basics/</id>
    <published>2016-11-09T11:42:15.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Swift是类型安全的语言；</li><li>Swift introduces optional types, which handle the absence of a value. Optional say either “there is a value, and it equals x” or “there isn’t a value at all”.</li><li><p>类型注解</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> red, green, double: <span class="type">Double</span></span><br></pre></td></tr></table></figure></li><li><p>类型别名（Type Alias）</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br><span class="line"><span class="keyword">var</span> maxAmplitudeFound <span class="operator">=</span> <span class="type">AudioSample</span>.min</span><br></pre></td></tr></table></figure></li><li><p>元组（Tuples）：元组内的值可以是不同类型的任何值。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">//http404Error的类型是(Int, String)</span></span><br></pre></td></tr></table></figure><p> 分解（decompose）元组：可以使用下划线来忽略一些值</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, <span class="keyword">_</span>) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(status)</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p> 也可以使用下标来取出单个值:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status code is 404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status message is Not Found&quot;</span></span><br></pre></td></tr></table></figure><p> 可以在定义元组的时候，给每个元素命名：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status <span class="operator">=</span> (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure><p> 这个时候，可以这样获取每个元素的值：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http200Status.statusCode)</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>Optional type</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">//convertedNumber的类型是 Int?， 不是Int</span></span><br></pre></td></tr></table></figure><p> Swift的nil跟oc中的nil不同。In Objective-C, nil is a pointer to a nonexistent object. In Swift, nil is not a pointer – it’s the absence of a value of certain type. Optionals of any type can be set to nil, not just object types.</p><p> forced unwrapping<br> optional binding<br> implicity unwrapped optionals</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Swift是类型安全的语言；&lt;/li&gt;
&lt;li&gt;Swift introduces optional types, which handle the absence of a value. Optional say either “there is a value
      
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift的闭包（一）：闭包简介、闭包表达式的优化</title>
    <link href="https://xjshi.github.io/2016/11/08/Swift%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85%E7%AE%80%E4%BB%8B%E3%80%81%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://xjshi.github.io/2016/11/08/Swift的闭包（一）：闭包简介、闭包表达式的优化/</id>
    <published>2016-11-08T19:19:06.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>定义：Closures are self-contained blocks of functionality that can be passed around and used in your code. </p><p>跟oc中的block相似。</p><p>Capture can capture and store reference to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p><span id="more"></span><p>闭包以下面三种形式中的一种存在：</p><ol><li>全局函数是一个有名字并且不捕获任何变量的闭包；</li><li>嵌套函数（nested function）是有一个名字并且可以从他们的外层函数（enclosing function）捕获变量的闭包；</li><li>闭包表达式是没有名字，可以从他们的surrounding context中捕获变量；</li></ol><p>Swift的闭包有干净、清晰的格式，并且有足够的优化，包括：</p><ol><li>从上下文中推断参数和返回值；</li><li>Implicit returns from single-expression closures;</li><li>简短的参数名字；</li><li>尾闭包语法</li></ol><h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><p>闭包表达式提供几种语法优化，下面的例子展示通过迭代提炼一个单一的表达式sorted(by:)，来展示这些优化。</p><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>Swift的标准库提供一个叫做sorted(by:)的方法，基于用户提供的一个排序闭包的输出，可以对一个已知类型的数组进行排序。排序完成后，这个方法返回一个新的数组（跟原来的数组有相同的类型和元素数量）。</p><p>下面闭包表达式的例子，使用sorted(by:)方法对一组String值进行逆字母序排序。初始的数组如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br></pre></td></tr></table></figure><p>sorted(by:)方法接受一个带两个相同类型的参数并返回一个Bool值的闭包。如果第一个值需要出现在第二个值后边，闭包需要返回true，否则，返回false。</p><p>这个例子是对一组String值进行排序，所以排序的闭包的需要是一个(String,  String)-&gt;Bool类型的函数。</p><p>下面用一个正常的函数来作为这个排序闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward);</span><br></pre></td></tr></table></figure><h2 id="闭包表达式的语法"><a href="#闭包表达式的语法" class="headerlink" title="闭包表达式的语法"></a>闭包表达式的语法</h2><img src="/2016/11/08/Swift%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85%E7%AE%80%E4%BB%8B%E3%80%81%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96/swift-syntax.png" class=""><p>闭包表达式里的patameters可以是in-out参数，但不能有默认值。</p><p>下面这段代码展示闭包表示式的版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="从上下文推断类型"><a href="#从上下文推断类型" class="headerlink" title="从上下文推断类型"></a>从上下文推断类型</h2><p>因为上面例子中的闭包作为一个参数传递给了一个方法，Swift可以推断它参数的类型和返回值的类型。这个sorted(by:)方法是在一个String数组上调用，因此它的参数必须是一个(String, String) -&gt; Bool类型的函数。这意味着(String, String)和Bool类型不需要写出来作为闭包定义的一部分。因为所有的类型都可以推断出来，返回的箭头-&gt;和参数两边的小括号也可以被删除:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123;s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2&#125;)</span><br></pre></td></tr></table></figure><h2 id="从单表达式闭包隐式返回（Implicit-Returns-fro-Single-Expression-Closures）"><a href="#从单表达式闭包隐式返回（Implicit-Returns-fro-Single-Expression-Closures）" class="headerlink" title="从单表达式闭包隐式返回（Implicit Returns fro Single-Expression Closures）"></a>从单表达式闭包隐式返回（Implicit Returns fro Single-Expression Closures）</h2><p>单表达式闭包可以通过删除return关键字来隐式返回这个单表达式的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123;s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2&#125;)</span><br></pre></td></tr></table></figure><h2 id="简化参数名字（Shorthand-Argument-Names）"><a href="#简化参数名字（Shorthand-Argument-Names）" class="headerlink" title="简化参数名字（Shorthand Argument Names）"></a>简化参数名字（Shorthand Argument Names）</h2><p>Swift自动给内联闭包提供简短的参数名字，通过 <code>$0</code>, <code>$1</code>, <code>$2</code> 等来引用闭包的参数。</p><p>如果你在闭包表达式中使用简化的参数名字，你可以从闭包的定义中删除闭包的参数列表，并且简短参数名字的数量和类型将通过预期的函数类型来推断。因为这个闭包表达式完全的组成了它的body，这个in关键字也可以删除。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123;<span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="运算符函数（Operator-Functions）"><a href="#运算符函数（Operator-Functions）" class="headerlink" title="运算符函数（Operator Functions）"></a>运算符函数（Operator Functions）</h2><p>实际上，对于上面的例子有一个更简短的写法。Swift的String类型实现了针对String类型的大于操作符作为一个有两个String类型参数和Bool返回值的函数。恰好跟sorted(by:)的需求吻合。因此，你可以简单的传递一个大于操作符，Swift将推断你想使用针对String的实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><h2 id="尾闭包"><a href="#尾闭包" class="headerlink" title="尾闭包"></a>尾闭包</h2><p>如果你需要给一个函数传递一个闭包作为函数的最后的参数，并且闭包表达式很长，写成尾闭包是更好的选择。一个尾闭包被写在函数调用小括号的后边。当你写尾闭包语法的时候，你不用为函数调用的闭包写参数标签。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTasksAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用尾闭包的函数调用</span></span><br><span class="line">someFunctionThatTasksAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">//closure&#x27;s body</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用尾闭包的函数调用</span></span><br><span class="line">someFunctionThatTasksAClosure() &#123;</span><br><span class="line">    <span class="comment">//closure&#x27;s body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序的例子使用尾闭包语法可以这么写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reversedNames <span class="operator">=</span> names.sorted() &#123;</span><br><span class="line">    (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123;<span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span>&#125;</span><br></pre></td></tr></table></figure><p>如果闭包表达式是方法的唯一参数，并且你使用表达式作为尾闭包，那么在调用函数没有写在函数名后边的小括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123;<span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：The Swift Programming Language(Swift 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：Closures are self-contained blocks of functionality that can be passed around and used in your code. &lt;/p&gt;
&lt;p&gt;跟oc中的block相似。&lt;/p&gt;
&lt;p&gt;Capture can capture and store reference to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift的闭包（二）：捕获值</title>
    <link href="https://xjshi.github.io/2016/11/08/Swift%E7%9A%84%E9%97%AD%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8D%95%E8%8E%B7%E5%80%BC/"/>
    <id>https://xjshi.github.io/2016/11/08/Swift的闭包（二）：捕获值/</id>
    <published>2016-11-08T17:08:00.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>闭包可以从定义它的上下文中捕获常量和变量。</p><p>在Swift中，捕获值最简单的例子是嵌套函数，举个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>)</span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>在这个例子中incrementer()捕获两个值，分别是amount、runningTotal。可以运行一下，观察结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(incrementByTen())     <span class="comment">//10</span></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())     <span class="comment">//20</span></span><br><span class="line"><span class="keyword">let</span> incrementByNine <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(incrementByNine())    <span class="comment">//9</span></span><br><span class="line"><span class="built_in">print</span>(incrementByNine())    <span class="comment">//18</span></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())     <span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>注意：如果你把闭包赋值给一个类实例的一个属性，并且闭包通过指向（refer fo）实例或者实例的成员捕获值，那么，在闭包和这个实例间就会有一个强引用环。 </p><h2 id="闭包是引用类型（Reference-Type）"><a href="#闭包是引用类型（Reference-Type）" class="headerlink" title="闭包是引用类型（Reference Type）"></a>闭包是引用类型（Reference Type）</h2><p>闭包和函数都是引用类型。</p><h2 id="Nonescaping-Closures"><a href="#Nonescaping-Closures" class="headerlink" title="Nonescaping Closures"></a>Nonescaping Closures</h2><p>当一个闭包作为参数传递给一个函数，但是在函数返回后调用的时候，我们说一个闭包是escaped的。当你声明一个有一个闭包作为参数的函数的时候，你可以在参数类型前写@nonescape来暗示这个closure不允许escape。如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: <span class="meta">@noescape</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个闭包标记用@nonescape让你在闭包内隐式的引用（refer to）self，看下这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;200&quot;</span></span><br><span class="line"> </span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;100&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Autoclosures"><a href="#Autoclosures" class="headerlink" title="Autoclosures"></a>Autoclosures</h2><p>An autoclosure is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it.</p><p>Autoclosures可以延迟计算（delay evaluation），因为直到调用闭包时，闭包内的代码才被运行。延迟计算对于有副作用或者计算代价昂贵的代码非常有用，因为你可以控制什么时候代码进行evaluation。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;5&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;5&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;4&quot;</span></span><br></pre></td></tr></table></figure><p>也可以传递给一个参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Alex!&quot;</span></span><br></pre></td></tr></table></figure><p>使用@autoclosure：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Ewa!&quot;</span></span><br></pre></td></tr></table></figure><p>注意：滥用autoclosure会使代码晦涩难懂。</p><p>@autoclosure属性隐含了@nonescape属性，如果你想要一个autoclosure允许esacpe，可以这样使用 @autoclosure(escaping) ，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span>(escaping) () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Collected 2 closures.&quot;</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Barry!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;Now serving Daniella!&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包可以从定义它的上下文中捕获常量和变量。&lt;/p&gt;
&lt;p&gt;在Swift中，捕获值最简单的例子是嵌套函数，举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeIncrementer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;forIncrement&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;amount&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&lt;/span&gt; -&amp;gt; () -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; runningTotal &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;incrementer&lt;/span&gt;()&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runningTotal &lt;span class=&quot;operator&quot;&gt;+=&lt;/span&gt; amount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; runningTotal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; incrementer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://xjshi.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>用户体验之音频</title>
    <link href="https://xjshi.github.io/2016/07/08/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E4%B9%8B%E9%9F%B3%E9%A2%91/"/>
    <id>https://xjshi.github.io/2016/07/08/用户体验之音频/</id>
    <published>2016-07-08T19:34:07.000Z</published>
    <updated>2023-12-13T12:25:29.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>早期某知名公司的应用有这么一个问题，如果我在听音乐时打开该应用，播放一段小视频，视频播放完成之后，音乐没有继续播放。这个问题被很多用户吐槽，很久以后，该公司终于修复了这个问题。</p></blockquote><p>无论声音是应用体验的重要部分，还是作为润色，你都应该知道用户期待声音有怎样的行为。</p><span id="more"></span><p>用户可以通过音量键、静音开关、耳机，以及音量滑条来控制声音，一些第三方的附件也可以控制声音。音频可以通过内部或外接的扬声器、耳机来输出，甚至是无线的 AirPlay 设备或 蓝牙设备。</p><ul><li>静音（Silence）。静音的情况下，用户希望不被意外的声音打扰，比如来电铃声、信息铃声、以及各种不重要的声音，比如，按键声、游戏配音、其他的听觉反馈等。用户只期待明确开始的声音，比如多媒体播放、闹钟、音频或视频信息。</li><li>音量（Volume）。当用户使用手机上的物理按键或屏幕上的音量滑条来调节声音时，用户期待这个调整可以在系统层面影响所有的声音，包括音乐播放、应用内声音。唯一的例外是铃音音量（ringer volume），铃音音量总是在没有音频播放的时候单独调节。</li><li>耳机（Headphone）。当用户插入耳机的时候，希望声音能自动切换线路（route）。当拔掉耳机的时候，期待播放暂停。</li></ul><p><strong>必要时可自动调节音量（不是总体的音量）</strong>。应用可以调节相对独立的音量来实现想要的效果。然而，最终的输出应该总是受系统音量控制。</p><p><strong>合适的时候重新选择线路</strong>。比如，你家的客厅有立体声系统，又有 Apple TV。那你应该支持在这些中间切换，除非是特殊原因。</p><p><strong>使用系统提供的音量视图来允许音量调节</strong>。调节音量时，提供一个界面控件无疑是很好的。iOS 系统为我们提供了<code>MPVolumeView</code>（<a href="https://developer.apple.com/reference/mediaplayer/mpvolumeview">点击查看详情</a>）。</p><p><strong>为短声和震动，使用系统声音服务</strong>。这个指的是<code>AudioToolbox</code>（<a href="https://developer.apple.com/reference/audiotoolbox/system_sound_services">System Sound Services</a>）。</p><p><strong>如果你的应用必须使用声音，那么给音频归类</strong>。实际上指的是<code>AVAudioSession</code>的 category，当其值不同，表现也不同。具体看下表：</p><table><thead><tr><th>category</th><th>含义</th><th>表现</th></tr></thead><tbody><tr><td>Solo ambient</td><td>声音不是必须的（essential），但是它会静默其他音频。比如，带有配乐的游戏。</td><td>1.受静音开关控制。2.不和其他声音混合（mix）。3.应用在后台时不播放。</td></tr><tr><td>Ambient</td><td>声音不是必须的，并且不会静默其他音频。比如，一个游戏应用可以让用户在玩游戏时播放另一个应用中的音乐，来替代游戏的配乐。</td><td>1.受静音开关控制。2.和其他声音混合。3.应用在后台时不播放。</td></tr><tr><td>Playback</td><td>声音是必须的，并且跟其他声音混合。比如，语音电子书应用，用户可能想在离开应用后，仍然可以听。</td><td>1.不受静音开关控制。2.可能混合，也可能不混合其他声音。3.可以在后台播放。</td></tr><tr><td>Record</td><td>录音。比如，语音备忘录这类应用。</td><td>不受静音开关控制。2.不和其他声音混合。3.可以在后台录音。</td></tr><tr><td>Play and Record</td><td>声音可能同时被录制和播放。例如，一个语音信息应用。</td><td>1.不受静音开关控制。2.可能混合，也可能不混合其他声音。3.可以在后台录制或播放。</td></tr></tbody></table><p><strong>被打断以后，在合适的时间继续播放</strong>。有时候，当前播放的音频可能被另一个应用打断。临时打断可以重新开始，比如打进来的电话。永久打断不能重新开始，比如由 Siri 开始的音乐播放列表。</p><p><strong>在你的应用结束一段临时的语音播放时，让其他应用知道</strong>。如果你的应用可能会临时打断其他应用的音频，你应该在合适的时候让其他应用可以安全的重新开始时得到通知。实现细节可以看这里：<a href="https://developer.apple.com/reference/avfoundation/avaudiosessionsetactiveoptions/avaudiosessionsetactiveoptionnotifyothersondeactivation">AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation</a>。</p><p><strong>不要重新调整音频附件</strong>。人们希望在所有的应用中，音频附件的行为一致。一定不要重新定义一个语音附件的意义。如果你的应用不支持某种附件，不响应它就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;早期某知名公司的应用有这么一个问题，如果我在听音乐时打开该应用，播放一段小视频，视频播放完成之后，音乐没有继续播放。这个问题被很多用户吐槽，很久以后，该公司终于修复了这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论声音是应用体验的重要部分，还是作为润色，你都应该知道用户期待声音有怎样的行为。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://xjshi.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>What is new in iOS 10</title>
    <link href="https://xjshi.github.io/2016/06/18/What-is-new-in-iOS-10/"/>
    <id>https://xjshi.github.io/2016/06/18/What-is-new-in-iOS-10/</id>
    <published>2016-06-18T20:12:04.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>个人认为 iOS 10 是 iOS 7 之后最大的改版，刚装上测试版的时候，感觉是新奇又有一点不适应。</p><p>下面主要来看一下开发者需要关心的部分。</p><h2 id="Providing-Haptic-Feedback"><a href="#Providing-Haptic-Feedback" class="headerlink" title="Providing Haptic Feedback"></a>Providing Haptic Feedback</h2><p>主要是体现在 iPhone 7 和 iPhone 7 Plus 两款设备上。为此，<code>UIKit</code>中引入了<code>UIFeedbackGenerator</code>这个类和三个子类，这些类能让触觉对特定的场景更加合适。</p><table><thead><tr><th>类名</th><th>使用示例</th></tr></thead><tbody><tr><td>UIImpactFeedbackGenerator</td><td>对完成一个功能或任务的视觉反馈提供一个物理的体验。比如，一个视图滑到指定位置时，或者两个对象碰撞时，用户可能感到砰地一声。</td></tr><tr><td>UINotificationFeedbackGenerator</td><td>比如，存入支票、解锁汽车这样的任务（功能）完成、失败或者产生某种类型的警告。</td></tr><tr><td>UISelectionFeedbackGenerator</td><td>暗示选择在积极得改变。例如，用户轻触一个滚动的picker。</td></tr></tbody></table><p>使用的时候，让系统对指定的场景生成触感（haptic），然后 iOS 会给予场景管理反馈的强度和行为。</p><h2 id="SirtKit"><a href="#SirtKit" class="headerlink" title="SirtKit"></a>SirtKit</h2><p>SiriKit 让特定领域的应用可以通过 iOS 中的 Siri 来使用服务。如果应用要接入的话，需要通过 Intents Extension来实现。目前 SiriKit 支持下面这几种领域：</p><ul><li>语音通话、视频通话</li><li>短信息</li><li>支付、接收付款</li><li>搜索照片</li><li>约车</li><li>训练管理</li><li><del>car play(automotive vendors only)<del></li><li><del>餐馆预订（需要苹果的额外支持）<del></li></ul><h2 id="iMessage-App"><a href="#iMessage-App" class="headerlink" title="iMessage App"></a>iMessage App</h2><p>iOS 10 中，可以通过开发应用扩展来来 Messages 这个应用中发送文本，表情，多媒体文件，甚至是可交互的消息。</p><p>可以开发两种类型的应用扩展：</p><ul><li>Sticker pack： 提供一组可以在 Messages 应用中使用的表情。</li><li>iMessage app： 可以在 Messages 应用中展现自定义的用户交互。</li></ul><p>开发 Sticker pack 不需要写然和代码，只要把图片拖到 asset 目录中就可以了。<br>开发 iMessage app 需要 Message 框架中的相关 API。</p><h2 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h2><p>iOS 10 引入了新的 API 来支持语音识别，并可以转为为子。通过 Speech 框架中的相关 API，即可以进行实时转换，也可以从录音文件中转换。</p><h2 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h2><p>对 VoIP 应用是一大福音，同时也能够满足 iOS 用户期待已久的功能—-知道呼入者是快递，还是房产中介。腾讯手机管家已经通过 CallKit 实现了后边描述的这个功能。</p><h2 id="User-Notifications"><a href="#User-Notifications" class="headerlink" title="User Notifications"></a>User Notifications</h2><p>iOS 10 之前，设备收到通知时，只能选择清除或者通过通知打开应用。iOS 10 引入了 UserNotification 框架，支持分发、处理应用。应用可以使用这个框架来接收或者在设备收到通知时悄悄的改变通知。</p><p>iOS 10 同时也引入了 UserNotificationsUI 框架，能让你通过扩展自定义通过的外观。</p><h2 id="App-Extensions"><a href="#App-Extensions" class="headerlink" title="App Extensions"></a>App Extensions</h2><p>iOS 10 引入了一些新玩意，以便创建应用扩展，千遍已经提到了一些，这里再次列举一下：</p><ul><li>Call Directory</li><li>Intents</li><li>Intents UI</li><li>Messages</li><li>Notification Content</li><li>Notification Service</li><li>Sticker Pack</li></ul><p>到这里 iOS 10 新增的部分基本介绍完了，除了这些，iOS 10 还对已有的部分框架做了增强，可自行到苹果开发者网站查阅。</p><p>iOS 9.3 到 iOS 10 的 API 变化可以看这里：<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html">https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;个人认为 iOS 10 是 iOS 7 之后最大的改版，刚装上测试版的时候，感觉是新奇又有一点不适应。&lt;/p&gt;
&lt;p&gt;下面主要来看一下开发者需要关心的部分。&lt;/p&gt;
&lt;h2 id=&quot;Providing-Haptic-Feedback&quot;&gt;&lt;a href=&quot;#Providing
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://xjshi.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Core Bluetooth</title>
    <link href="https://xjshi.github.io/2016/04/21/Core-Bluetooth/"/>
    <id>https://xjshi.github.io/2016/04/21/Core-Bluetooth/</id>
    <published>2016-04-21T19:50:54.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍蓝牙4.0的一些基本知识。</p><h2 id="基本概念、服务器、客户端"><a href="#基本概念、服务器、客户端" class="headerlink" title="基本概念、服务器、客户端"></a>基本概念、服务器、客户端</h2><p>蓝牙LE是一个基于点对点的通信系统，其中一台设备作为服务器，另一台设备作为客户端。拥有数据的设备作为服务器，消费数据的设备作为客户端。</p><p>比如，心率监测器、温控器、手环等，都可以是服务器。服务器通过广播确定自己产生什么类型的数据并把数据发送给连接上的客户端。</p><p>客户端是对数据感兴趣的设备，客户端必须自己发现感兴趣的设备。客户端负责初始化对服务器的连接然后开始读取数据。</p><span id="more"></span><h2 id="类与协议"><a href="#类与协议" class="headerlink" title="类与协议"></a>类与协议</h2><p>在iOS中，服务器叫做外围设备（Peripheral），客户端叫做中心设备（Central）。iOS 系统允许iOS设备从一个蓝牙设备读取数据。在<code>CoreBluetooth.framework</code>中，读取设备对应<code>CBCentralManager</code>这个类，外围设备用<code>CBPeripheral</code>这个类来表示。<code>CBPeripheralManager</code>和<code>CBCentral</code>这两个类表示客户端设备。</p><table><thead><tr><th>类名</th><th>介绍</th></tr></thead><tbody><tr><td>CBCentralManager</td><td>该类的对象用于管理发现的或者连接的外围设备。在调用该类的方法前，你需要确定蓝牙设备是可用的。</td></tr><tr><td>CBPeripheral</td><td>代表外围设备，每个外围设备通过 UUID 来标识。外围设备可以包含一个或者多个服务、或者提供关于连接的信号强度的信息。</td></tr><tr><td>CBCentral</td><td>代表中心设备。</td></tr></tbody></table><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="通过扫描寻找服务"><a href="#通过扫描寻找服务" class="headerlink" title="通过扫描寻找服务"></a>通过扫描寻找服务</h3><p>外围设备是提供数据的服务器，在提供数据之前，必须广播自己能够提供的服务。中心设备扫描这些包来探测附近的外围设备。一个服务器使用全局唯一的UUID来标识自己。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.centralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.centralManager.state == CBManagerStatePoweredOn) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.centralManager scanForPeripheralsWithServices:<span class="literal">nil</span> options:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找到之后会回调<code>- (void)centralManager:didDiscoverPeripheral:advertisementData:RSSI:</code>方法，这这个方法内部你可以做连接外围设备等操作。</p><h3 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)advertisementData RSSI:(<span class="built_in">NSNumber</span> *)RSSI &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.peripherals containsObject:peripheral]) &#123;</span><br><span class="line">        peripheral.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.peripherals addObject:peripheral];</span><br><span class="line">        [<span class="keyword">self</span>.centralManager connectPeripheral:peripheral options:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果你知道外围设备的 UUID ，那么根据 UUID 直接获取外围设备来连接也是可以的，我也建议你这么做（因为省电又快速）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>&lt;CBPeripheral *&gt; *peripheral = [<span class="keyword">self</span>.centralManager retrievePeripheralsWithIdentifiers:@[[CBUUID UUIDWithString:<span class="string">@&quot;设备的uuid&quot;</span>]]];</span><br></pre></td></tr></table></figure><blockquote><p>注意UUID的格式一定要写对，是这样的<code>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code>，其中每一个X代表一个十六进制字符。在终端中输入<code>uuidgen</code>可以生成一个，你可以观察一下。</p></blockquote><h3 id="发现服务"><a href="#发现服务" class="headerlink" title="发现服务"></a>发现服务</h3><p>如果连接成功外围设备，就会回调<code>- (void)centralManager:didConnectPeripheral:</code>方法，可以在这里发现外围设备设备提供的服务。如果发现服务，会回调<code>CBPeripheralDelegate</code>中的<code>- (void)peripheral:didDiscoverServices:</code>方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123;</span><br><span class="line">    [peripheral discoverServices:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发现特性"><a href="#发现特性" class="headerlink" title="发现特性"></a>发现特性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [peripheral.services enumerateObjectsUsingBlock:^(CBService * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, obj.peripheral.name);</span><br><span class="line">        [peripheral discoverCharacteristics:<span class="literal">nil</span> forService:obj];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对特性写数据"><a href="#针对特性写数据" class="headerlink" title="针对特性写数据"></a>针对特性写数据</h3><p>发现特性之后，就可以针对特性做数据处理了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didDiscoverCharacteristicsForService:(CBService *)service</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是作为 Central 时，需要用到的基本 API。作为 Peripheral 时，需要时再总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍蓝牙4.0的一些基本知识。&lt;/p&gt;
&lt;h2 id=&quot;基本概念、服务器、客户端&quot;&gt;&lt;a href=&quot;#基本概念、服务器、客户端&quot; class=&quot;headerlink&quot; title=&quot;基本概念、服务器、客户端&quot;&gt;&lt;/a&gt;基本概念、服务器、客户端&lt;/h2&gt;&lt;p&gt;蓝牙LE是一个基于点对点的通信系统，其中一台设备作为服务器，另一台设备作为客户端。拥有数据的设备作为服务器，消费数据的设备作为客户端。&lt;/p&gt;
&lt;p&gt;比如，心率监测器、温控器、手环等，都可以是服务器。服务器通过广播确定自己产生什么类型的数据并把数据发送给连接上的客户端。&lt;/p&gt;
&lt;p&gt;客户端是对数据感兴趣的设备，客户端必须自己发现感兴趣的设备。客户端负责初始化对服务器的连接然后开始读取数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://xjshi.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Go 中利用 channel 处理超时</title>
    <link href="https://xjshi.github.io/2016/04/09/Go-%E4%B8%AD%E5%88%A9%E7%94%A8-channel-%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6/"/>
    <id>https://xjshi.github.io/2016/04/09/Go-中利用-channel-处理超时/</id>
    <published>2016-04-09T12:11:43.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>并发中超时处理是必不可少的，golang没有提供直接的超时处理机制，但可以利用select机制来解决超时问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeoutFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//首先，实现并执行一个匿名的超时等待函数</span></span><br><span class="line">    timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1e9</span>) <span class="comment">//等待1秒钟</span></span><br><span class="line">        timeout &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//然后，我们把timeout这个channel利用起来</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ch:</span><br><span class="line">            <span class="comment">//从ch中读到数据</span></span><br><span class="line">        <span class="keyword">case</span> &lt;- timeout:</span><br><span class="line">            <span class="comment">//一直没有从ch中读取到数据，但从timeout中读取到数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;并发中超时处理是必不可少的，golang没有提供直接的超时处理机制，但可以利用select机制来解决超时问题。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://xjshi.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 中的 BOOL</title>
    <link href="https://xjshi.github.io/2016/03/02/Objective-C-%E4%B8%AD%E7%9A%84-BOOL/"/>
    <id>https://xjshi.github.io/2016/03/02/Objective-C-中的-BOOL/</id>
    <published>2016-03-02T21:30:45.000Z</published>
    <updated>2023-12-13T12:25:29.685Z</updated>
    
    <content type="html"><![CDATA[<p>之前开发了一个针对单个数据模型，自动建表、增删改查等操作的小工具，后边在 iPhone 5c 上使用时，出现了 crash 的情况。</p><p>经定位，问题就出在了模型中的 BOOL 类型的属性上。</p><span id="more"></span><p>看下 BOOL 在 objc.h 中的定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Type to represent a boolean value.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_BOOL_IS_BOOL 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="built_in">BOOL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC_BOOL_IS_CHAR 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="built_in">BOOL</span>; </span><br><span class="line"><span class="comment">// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot; </span></span><br><span class="line"><span class="comment">// even if -funsigned-char is used.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>显而易见，在64位系统下，实际上时 bool 类型；而在32位系统下，是 signed char 类型的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前开发了一个针对单个数据模型，自动建表、增删改查等操作的小工具，后边在 iPhone 5c 上使用时，出现了 crash 的情况。&lt;/p&gt;
&lt;p&gt;经定位，问题就出在了模型中的 BOOL 类型的属性上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://xjshi.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>
